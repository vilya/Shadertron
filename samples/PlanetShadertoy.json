{
    "Shader": {
        "ver": "0.1",
        "info": {
            "id": "4tjGRh",
            "date": "1427737621",
            "viewed": 70925,
            "name": "Planet Shadertoy",
            "username": "reinder",
            "description": "A seamless space-to-surface flight. This is a tribute to all the great shaders on Shadertoy! Use chrome without angle (or a Mac) and run this shader on med, or high settings (line 4 or 5) to get the full shader and the detail I was aiming for.",
            "likes": 220,
            "published": 3,
            "flags": 9,
            "tags": [
                "terrain",
                "sea",
                "space",
                "ocean",
                "planet",
                "shadertoy",
                "vr",
                "asteroids"
            ],
            "hasliked": 0
        },
        "renderpass": [
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": 37,
                        "channel": 0
                    }
                ],
                "code": "// Planet Shadertoy. Created by Reinder Nijhoff 2015\n// @reindernijhoff\n//\n// https://www.shadertoy.com/view/4tjGRh\n//\n\n//#define HIGH_QUALITY\n//#define MED_QUALITY\n//#define LOW_QUALITY\n#define VERY_LOW_QUALITY\n\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = (PI / 180.0);\nconst float MAX = 10000.0;\n\nconst float EARTH_RADIUS = 1000.;\nconst float EARTH_ATMOSPHERE = 5.;\nconst float EARTH_CLOUDS = 1.;\n\nconst float RING_INNER_RADIUS = 1500.;\nconst float RING_OUTER_RADIUS = 2300.;\nconst float RING_HEIGHT = 2.;\n\n#ifdef HIGH_QUALITY\n    const int   SEA_NUM_STEPS = 7;\n    const int\tTERRAIN_NUM_STEPS = 140;\n    const int   ASTEROID_NUM_STEPS = 11;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 7;\n    const int   RING_VOXEL_STEPS = 25;\n    const float ASTEROID_MAX_DISTANCE = 1.1; \n\tconst int   FBM_STEPS = 4;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 5;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 7;\n\n    #define DISPLAY_LLAMEL\n    #define DISPLAY_CLOUDS\n    #define DISPLAY_CLOUDS_DETAIL\n    #define DISPLAY_TERRAIN_DETAIL\n#endif\n\n#ifdef MED_QUALITY\n    const int   SEA_NUM_STEPS = 6;\n    const int\tTERRAIN_NUM_STEPS = 100;\n    const int   ASTEROID_NUM_STEPS = 10;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 6;\n    const int   RING_VOXEL_STEPS = 24;\n    const float ASTEROID_MAX_DISTANCE = 1.; \n\tconst int   FBM_STEPS = 4;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 4;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 6;\n    #define DISPLAY_CLOUDS\n    #define DISPLAY_TERRAIN_DETAIL\n    #define DISPLAY_CLOUDS_DETAIL\n#endif\n\n#ifdef LOW_QUALITY\n    const int   SEA_NUM_STEPS = 5;\n    const int\tTERRAIN_NUM_STEPS = 75;\n    const int   ASTEROID_NUM_STEPS = 9;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 5;\n    const int   RING_VOXEL_STEPS = 20;\n    const float ASTEROID_MAX_DISTANCE = .85; \n\tconst int   FBM_STEPS = 3;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 3;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 5;\n#endif\n\n#ifdef VERY_LOW_QUALITY\n    const int   SEA_NUM_STEPS = 4;\n    const int\tTERRAIN_NUM_STEPS = 60;\n    const int   ASTEROID_NUM_STEPS = 7;\n\tconst int\tASTEROID_NUM_BOOL_SUB = 4;\n    const int   RING_VOXEL_STEPS = 16;\n    const float ASTEROID_MAX_DISTANCE = .67; \n\tconst int   FBM_STEPS = 3;\n    const int   ATMOSPHERE_NUM_OUT_SCATTER = 2;\n    const int   ATMOSPHERE_NUM_IN_SCATTER = 4;\n\t#define HIDE_TERRAIN\n#endif\n\nconst vec3  SUN_DIRECTION = vec3( .940721,  .28221626, .18814417 );\nconst vec3  SUN_COLOR = vec3(.3, .21, .165);\n\nfloat time;\n\n//-----------------------------------------------------\n// Noise functions\n//-----------------------------------------------------\n\nfloat hash( const in float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nfloat hash( const in vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\nvec3 hash31( const in float p) {\n\tvec3 h = vec3(1275.231,4461.7,7182.423) * p;\t\n    return fract(sin(h)*43758.543123);\n}\nvec3 hash33( const in vec3 p) {\n    return vec3( hash(p), hash(p.zyx), hash(p.yxz) );\n}\n\nfloat noise( const in  float p ) {    \n    float i = floor( p );\n    float f = fract( p );\t\n\tfloat u = f*f*(3.0-2.0*f);\n    return -1.0+2.0* mix( hash( i + 0. ), hash( i + 1. ), u);\n}\n\nfloat noise( const in  vec2 p ) {    \n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise( const in  vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*157.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+157.0), hash(n+158.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\n\nfloat tri( const in vec2 p ) {\n    return 0.5*(cos(6.2831*p.x) + cos(6.2831*p.y));\n   \n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( in vec2 p ) {\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); \n    \n#ifndef LOW_QUALITY\n#ifndef VERY_LOW_QUALITY\n    p = m2*p*2.01;\n    f += 0.0625*noise( p );\n#endif\n#endif\n    return f/0.9375;\n}\n\nfloat fbm( const in vec3 p, const in float a, const in float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < FBM_STEPS; i++) {\n        float n = pow(noise(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n//-----------------------------------------------------\n// Lightning functions\n//-----------------------------------------------------\n\nfloat diffuse( const in vec3 n, const in vec3 l) { \n    return clamp(dot(n,l),0.,1.);\n}\n\nfloat specular( const in vec3 n, const in vec3 l, const in vec3 e, const in float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\nfloat fresnel( const in vec3 n, const in vec3 e, float s ) {\n    return pow(clamp(1.-dot(n,e), 0., 1.),s);\n}\n\n//-----------------------------------------------------\n// Math functions\n//-----------------------------------------------------\n\nvec2 rotate(float angle, vec2 v) {\n    return vec2(cos(angle) * v.x + sin(angle) * v.y, cos(angle) * v.y - sin(angle) * v.x);\n}\n\nfloat boolSub(float a,float b) { \n    return max(a,-b); \n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n//-----------------------------------------------------\n// Intersection functions (by iq)\n//-----------------------------------------------------\n\nvec3 nSphere( in vec3 pos, in vec4 sph ) {\n    return (pos-sph.xyz)/sph.w;\n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph ) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nfloat iCSphereF( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return -MAX;\n\treturn -b + sqrt( d );\n}\n\nvec2 iCSphere2( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) return vec2( MAX, -MAX );\n\td = sqrt( d );\n\treturn vec2( -b - d, -b + d );\n}\n\nvec3 nPlane( in vec3 ro, in vec4 obj ) {\n    return obj.xyz;\n}\n\nfloat iPlane( in vec3 ro, in vec3 rd, in vec4 pla ) {\n    return (-pla.w - dot(pla.xyz,ro)) / dot( pla.xyz, rd );\n}\n\n//-----------------------------------------------------\n// Wet stone by TDM\n// \n// https://www.shadertoy.com/view/ldSSzV\n//-----------------------------------------------------\n\nconst float ASTEROID_TRESHOLD \t= 0.001;\nconst float ASTEROID_EPSILON \t= 1e-6;\nconst float ASTEROID_DISPLACEMENT = 0.1;\nconst float ASTEROID_RADIUS = 0.13;\n\nconst vec3  RING_COLOR_1 = vec3(0.42,0.3,0.2);\nconst vec3  RING_COLOR_2 = vec3(0.41,0.51,0.52);\n\nfloat asteroidRock( const in vec3 p, const in vec3 id ) {  \n    float d = sphere(p,ASTEROID_RADIUS);    \n    for(int i = 0; i < ASTEROID_NUM_BOOL_SUB; i++) {\n        float ii = float(i)+id.x;\n        float r = (ASTEROID_RADIUS*2.5) + ASTEROID_RADIUS*hash(ii);\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0);\n    \td = boolSub(d,sphere(p+v*r,r * 0.8));       \n    }\n    return d;\n}\n\nfloat asteroidMap( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + noise(p*4.0) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nfloat asteroidMapDetailed( const in vec3 p, const in vec3 id) {\n    float d = asteroidRock(p, id) + fbm(p*4.0,0.4,2.96) * ASTEROID_DISPLACEMENT;\n    return d;\n}\n\nvoid asteroidTransForm(inout vec3 ro, const in vec3 id ) {\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( xyangle, ro.xy );\n    \n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( yzangle, ro.yz );\n}\n\nvoid asteroidUnTransForm(inout vec3 ro, const in vec3 id ) {\n    float yzangle = (id.y-.5)*time*2.;\n    ro.yz = rotate( -yzangle, ro.yz );\n\n    float xyangle = (id.x-.5)*time*2.;\n    ro.xy = rotate( -xyangle, ro.xy );  \n}\n\nvec3 asteroidGetNormal(vec3 p, vec3 id) {\n    asteroidTransForm( p, id );\n    \n    vec3 n;\n    n.x = asteroidMapDetailed(vec3(p.x+ASTEROID_EPSILON,p.y,p.z), id);\n    n.y = asteroidMapDetailed(vec3(p.x,p.y+ASTEROID_EPSILON,p.z), id);\n    n.z = asteroidMapDetailed(vec3(p.x,p.y,p.z+ASTEROID_EPSILON), id);\n    n = normalize(n-asteroidMapDetailed(p, id));\n    \n    asteroidUnTransForm( n, id );\n    return n;\n}\n\nvec2 asteroidSpheretracing(vec3 ori, vec3 dir, vec3 id) {\n    asteroidTransForm( ori, id );\n    asteroidTransForm( dir, id );\n    \n    vec2 td = vec2(0,1);\n    for(int i = 0; i < ASTEROID_NUM_STEPS && abs(td.y) > ASTEROID_TRESHOLD; i++) {\n        td.y = asteroidMap(ori + dir * td.x, id);\n        td.x += td.y;\n    }\n    return td;\n}\n\nvec3 asteroidGetStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n\treturn mix( diffuse(n,l)*RING_COLOR_1*SUN_COLOR, SUN_COLOR*specular(n,l,e,3.0), .5*fresnel(n,e,5.));    \n}\n\n//-----------------------------------------------------\n// Ring (by me ;))\n//-----------------------------------------------------\n\nconst float RING_DETAIL_DISTANCE = 40.;\nconst float RING_VOXEL_STEP_SIZE = .03;\n\nvec3 ringShadowColor( const in vec3 ro ) {\n    if( iSphere( ro, SUN_DIRECTION, vec4( 0., 0., 0., EARTH_RADIUS ) ) > 0. ) {\n        return vec3(0.);\n    }\n    return vec3(1.);\n}\n\nbool ringMap( const in vec3 ro ) {\n    return ro.z < RING_HEIGHT/RING_VOXEL_STEP_SIZE && hash(ro)<.5;\n}\n\nvec4 renderRingNear( const in vec3 ro, const in vec3 rd ) { \n// find startpoint \n    float d1 = iPlane( ro, rd, vec4( 0., 0., 1., RING_HEIGHT ) );\n    float d2 = iPlane( ro, rd, vec4( 0., 0., 1., -RING_HEIGHT ) );\n    \n    float d = min( max(d1,0.), max(d2,0.) );\n   \n    if( (d1 < 0. && d2 < 0.) || d > ASTEROID_MAX_DISTANCE ) {\n        return vec4( 0. );\n    } else {\n        vec3 ros = ro + rd*d;\n\n        // avoid precision problems..\n        vec2 mroxy = mod(ros.xy, vec2(10.));\n        vec2 roxy = ros.xy - mroxy;\n        ros.xy -= roxy;\n        ros /= RING_VOXEL_STEP_SIZE;\n        //ros.xy -= vec2(.013,.112)*time*.5;\n\n        vec3 pos = floor(ros);\n        vec3 ri = 1.0/rd;\n        vec3 rs = sign(rd);\n        vec3 dis = (pos-ros + 0.5 + rs*0.5) * ri;\n\n        float alpha = 0., dint;\n        vec3 offset = vec3(0), id, asteroidro;\n        vec2 asteroid = vec2(0);\n\n        for( int i=0; i<RING_VOXEL_STEPS; i++ ) {\n            if( ringMap(pos) ) {\n                id = hash33(pos);\n                offset = id*(1.-2.*ASTEROID_RADIUS)+ASTEROID_RADIUS;\n                dint = iSphere( ros, rd, vec4(pos+offset, ASTEROID_RADIUS) );\n\n                if( dint > 0. ) {\n                    asteroidro = ros+rd*dint-(pos+offset);\n                    asteroid = asteroidSpheretracing( asteroidro, rd, id );\n\n                    if( asteroid.y < .1 ) {\n                        alpha = 1.;\n                        break;\t    \n                    }\n                }\n\n            }\n            vec3 mm = step(dis.xyz, dis.yxy) * step(dis.xyz, dis.zzx);\n            dis += mm * rs * ri;\n            pos += mm * rs;\n        }\n\n        if( alpha > 0. ) {       \n            vec3 intersection = ros + rd*(asteroid.x+dint);\n            vec3 n = asteroidGetNormal( asteroidro + rd*asteroid.x, id );\n\n            vec3 col = asteroidGetStoneColor(intersection, .1, SUN_DIRECTION, n, rd);\n\n            intersection *= RING_VOXEL_STEP_SIZE;\n            intersection.xy += roxy;\n          //  col *= ringShadowColor( intersection );\n\n            return vec4( col, 1.-smoothstep(0.4*ASTEROID_MAX_DISTANCE, 0.5* ASTEROID_MAX_DISTANCE, distance( intersection, ro ) ) );\n        } else {\n            return vec4(0.);\n        }\n    }\n}\n\n//-----------------------------------------------------\n// Ring (by me ;))\n//-----------------------------------------------------\n\nfloat renderRingFarShadow( const in vec3 ro, const in vec3 rd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. ) {\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            return .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n        } else {\n            return 0.;\n        }\n    } else {\n\t    return 0.;\n    }\n}\n\nvec4 renderRingFar( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    // intersect plane\n    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n    \n    if( d > 0. && d < maxd ) {\n        maxd = d;\n\t    vec3 intersection = ro + rd*d;\n        float l = length(intersection.xy);\n        \n        if( l > RING_INNER_RADIUS && l < RING_OUTER_RADIUS ) {\n            float dens = .5 + .5 * (.2+.8*noise( l*.07 )) * (.5+.5*noise(intersection.xy));\n            vec3 col = mix( RING_COLOR_1, RING_COLOR_2, abs( noise(l*0.2) ) ) * abs(dens) * 1.5;\n            \n            col *= ringShadowColor( intersection );\n    \t\tcol *= .8+.3*diffuse( vec3(0,0,1), SUN_DIRECTION );\n\t\t\tcol *= SUN_COLOR;\n            return vec4( col, dens );\n        } else {\n            return vec4(0.);\n        }\n    } else {\n\t    return vec4(0.);\n    }\n}\n\nvec4 renderRing( const in vec3 ro, const in vec3 rd, inout float maxd ) {\n    vec4 far = renderRingFar( ro, rd, maxd );\n    float l = length( ro.xy );\n\n    if( abs(ro.z) < RING_HEIGHT+RING_DETAIL_DISTANCE \n        && l < RING_OUTER_RADIUS+RING_DETAIL_DISTANCE \n        && l > RING_INNER_RADIUS-RING_DETAIL_DISTANCE ) {\n     \t\n\t    float d = iPlane( ro, rd, vec4( 0., 0., 1., 0.) );\n        float detail = mix( .5 * noise( fract(ro.xy+rd.xy*d) * 92.1)+.25, 1., smoothstep( 0.,RING_DETAIL_DISTANCE, d) );\n        far.xyz *= detail;    \n    }\n    \n\t// are asteroids neaded ?\n    if( abs(ro.z) < RING_HEIGHT+ASTEROID_MAX_DISTANCE \n        && l < RING_OUTER_RADIUS+ASTEROID_MAX_DISTANCE \n        && l > RING_INNER_RADIUS-ASTEROID_MAX_DISTANCE ) {\n        \n        vec4 near = renderRingNear( ro, rd );\n        far = mix( far, near, near.w );\n        maxd=0.;\n    }\n            \n    return far;\n}\n\n//-----------------------------------------------------\n// Stars (by me ;))\n//-----------------------------------------------------\n\nvec4 renderStars( const in vec3 rd ) {\n\tvec3 rds = rd;\n\tvec3 col = vec3(0);\n    float v = 1.0/( 2. * ( 1. + rds.z ) );\n    \n    vec2 xy = vec2(rds.y * v, rds.x * v);\n    float s = noise(rds*134.);\n    \n    s += noise(rds*470.);\n    s = pow(s,19.0) * 0.00001;\n    if (s > 0.5) {\n        vec3 backStars = vec3(s)*.5 * vec3(0.95,0.8,0.9); \n        col += backStars;\n    }\n\treturn   vec4( col, 1 ); \n} \n\n//-----------------------------------------------------\n// Atmospheric Scattering by GLtracy\n// \n// https://www.shadertoy.com/view/lslXDr\n//-----------------------------------------------------\n\nconst float ATMOSPHERE_K_R = 0.166;\nconst float ATMOSPHERE_K_M = 0.0025;\nconst float ATMOSPHERE_E = 12.3;\nconst vec3  ATMOSPHERE_C_R = vec3( 0.3, 0.7, 1.0 );\nconst float ATMOSPHERE_G_M = -0.85;\n\nconst float ATMOSPHERE_SCALE_H = 4.0 / ( EARTH_ATMOSPHERE );\nconst float ATMOSPHERE_SCALE_L = 1.0 / ( EARTH_ATMOSPHERE );\n\nconst float ATMOSPHERE_FNUM_OUT_SCATTER = float(ATMOSPHERE_NUM_OUT_SCATTER);\nconst float ATMOSPHERE_FNUM_IN_SCATTER = float(ATMOSPHERE_NUM_IN_SCATTER);\n\nconst int   ATMOSPHERE_NUM_OUT_SCATTER_LOW = 2;\nconst int   ATMOSPHERE_NUM_IN_SCATTER_LOW = 4;\nconst float ATMOSPHERE_FNUM_OUT_SCATTER_LOW = float(ATMOSPHERE_NUM_OUT_SCATTER_LOW);\nconst float ATMOSPHERE_FNUM_IN_SCATTER_LOW = float(ATMOSPHERE_NUM_IN_SCATTER_LOW);\n\nfloat atmosphericPhaseMie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n    \n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\nfloat atmosphericPhaseReyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat atmosphericDensity( vec3 p ){\n\treturn exp( -( length( p ) - EARTH_RADIUS ) * ATMOSPHERE_SCALE_H );\n}\n\nfloat atmosphericOptic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec4 atmosphericInScatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n    float sumdensity = 0.;\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER; i++ ) {\n        vec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOptic( p, v ) + atmosphericOptic( v, u ) ) * ( PI * 4.0 );\n\t\tfloat dens = atmosphericDensity( v );\n  \n\t    float m = MAX;\n\t\tsum += dens * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) ) \n    \t\t* (1. - renderRingFarShadow( u, SUN_DIRECTION ) );\n \t\tsumdensity += dens;\n        \n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn vec4( sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                         ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E, \n                \t     clamp(sumdensity * len * ATMOSPHERE_SCALE_L,0.,1.));\n}\n\nfloat atmosphericOpticLow( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / ATMOSPHERE_FNUM_OUT_SCATTER_LOW;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < ATMOSPHERE_NUM_OUT_SCATTER_LOW; i++ ) {\n\t\tsum += atmosphericDensity( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * ATMOSPHERE_SCALE_L;\n\t\n\treturn sum;\n}\n\nvec3 atmosphericInScatterLow( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / ATMOSPHERE_FNUM_IN_SCATTER_LOW;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\n    for ( int i = 0; i < ATMOSPHERE_NUM_IN_SCATTER_LOW; i++ ) {\n\t\tvec3 u = v + l * iCSphereF( v, l, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\t\tfloat n = ( atmosphericOpticLow( p, v ) + atmosphericOpticLow( v, u ) ) * ( PI * 4.0 );\n\t    float m = MAX;\n\t\tsum += atmosphericDensity( v ) * exp( -n * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R + ATMOSPHERE_K_M ) );\n\t\tv += step;\n\t}\n\tsum *= len * ATMOSPHERE_SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( ATMOSPHERE_K_R * ATMOSPHERE_C_R * atmosphericPhaseReyleigh( cc ) + \n                   ATMOSPHERE_K_M * atmosphericPhaseMie( ATMOSPHERE_G_M, c, cc ) ) * ATMOSPHERE_E;\n}\n\nvec4 renderAtmospheric( const in vec3 ro, const in vec3 rd, inout float d ) {    \n    // inside or outside atmosphere?\n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n\tvec2 f = iCSphere2( ro, rd, EARTH_RADIUS );\n        \n    if( length(ro) <= EARTH_RADIUS + EARTH_ATMOSPHERE ) {\n        if( d < e.y ) {\n            e.y = d;\n        }\n\t\td = e.y;\n\t    e.x = 0.;\n        \n\t    if ( iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS)) > 0. ) {\n\t        d = iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS));\n\t\t}\n    } else {\n    \tif(  iSphere( ro, rd, vec4(0,0,0,EARTH_RADIUS + EARTH_ATMOSPHERE )) < 0. ) return vec4(0.);\n        \n        if ( e.x > e.y ) {\n        \td = MAX;\n\t\t\treturn vec4(0.);\n\t\t}\n\t\td = e.y = min( e.y, f.x );\n    }\n\treturn atmosphericInScatter( ro, rd, e, SUN_DIRECTION );\n}\n\nvec3 renderAtmosphericLow( const in vec3 ro, const in vec3 rd ) {    \n    vec2 e = iCSphere2( ro, rd, EARTH_RADIUS + EARTH_ATMOSPHERE );\n    e.x = 0.;\n    return atmosphericInScatterLow( ro, rd, e, SUN_DIRECTION );\n}\n\n//-----------------------------------------------------\n// Seascape by TDM\n// \n// https://www.shadertoy.com/view/Ms2SD1\n//-----------------------------------------------------\n\nconst int   SEA_ITER_GEOMETRY = 3;\nconst int   SEA_ITER_FRAGMENT = 5;\n\nconst float SEA_EPSILON\t= 1e-3;\n#define       SEA_EPSILON_NRM\t(0.1 / iResolution.x)\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3  SEA_BASE = vec3(0.1,0.19,0.22);\nconst vec3  SEA_WATER_COLOR = vec3(0.8,0.9,0.6);\nfloat       SEA_TIME;\nconst mat2  sea_octave_m = mat2(1.6,1.2,-1.2,1.6);\n\nfloat seaOctave( in vec2 uv, const in float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat seaMap(const in vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_GEOMETRY; i++) {        \n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat seaMapHigh(const in vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < SEA_ITER_FRAGMENT; i++) {        \n    \td = seaOctave((uv+SEA_TIME)*freq,choppy);\n    \td += seaOctave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= sea_octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 seaGetColor( const in vec3 n, vec3 eye, const in vec3 l, const in float att, \n                  const in vec3 sunc, const in vec3 upc, const in vec3 reflected) {  \n    vec3 refracted = SEA_BASE * upc + diffuse(n,l) * SEA_WATER_COLOR * 0.12 * sunc; \n    vec3 color = mix(refracted,reflected,fresnel(n, -eye, 3.)*.65 );\n    \n    color += upc*SEA_WATER_COLOR * (att * 0.18);\n    color += sunc * vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\nvec3 seaGetNormal(const in vec3 p, const in float eps) {\n    vec3 n;\n    n.y = seaMapHigh(p);    \n    n.x = seaMapHigh(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = seaMapHigh(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat seaHeightMapTracing(const in vec3 ori, const in vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = seaMap(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = seaMap(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < SEA_NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = seaMap(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 seaTransform( in vec3 x ) {\n    x.yz = rotate( 0.8, x.yz );\n    return x;\n}\n\nvec3 seaUntransform( in vec3 x ) {\n    x.yz = rotate( -0.8, x.yz );\n    return x;\n}\n\nvoid renderSea( const in vec3 ro, const in vec3 rd, inout vec3 n, inout float att ) {    \n    vec3 p,\n    rom = seaTransform(ro),\n    rdm = seaTransform(rd);\n    \n    rom.y -= EARTH_RADIUS;\n    rom *= 1000.;\n    rom.xz += vec2(3.1,.2)*time;\n\n    SEA_TIME = time * SEA_SPEED;\n    \n    seaHeightMapTracing(rom,rdm,p);\n    float squareddist = dot(p - rom, p-rom );\n    n = seaGetNormal(p, squareddist * SEA_EPSILON_NRM );\n    \n    n = seaUntransform(n);\n    \n    att = clamp(SEA_HEIGHT+p.y, 0.,1.);\n}\n\n//-----------------------------------------------------\n// Terrain based on Elevated and Terrain Tubes by IQ\n//\n// https://www.shadertoy.com/view/MdX3Rr\n// https://www.shadertoy.com/view/4sjXzG\n//-----------------------------------------------------\n\n#ifndef HIDE_TERRAIN\n\nconst mat2 terrainM2 = mat2(1.6,-1.2,1.2,1.6);\n\nfloat terrainLow( vec2 p ) {\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<2; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n\treturn t*33.0;\n}\n\nfloat terrainMed( vec2 p ) {\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<6; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n            \n    return t*33.0;\n}\n\nfloat terrainHigh( vec2 p ) {\n    vec2 q = p;\n    p *= 0.0013;\n\n    float s = 1.0;\n\tfloat t = 0.0;\n\tfor( int i=0; i<7; i++ ) {\n        t += s*tri( p );\n\t\ts *= 0.5 + 0.1*t;\n        p = 0.97*terrainM2*p + (t-0.5)*0.12;\n\t}\n    \n    t += t*0.015*fbm( q );\n\treturn t*33.0;\n}\n\nfloat terrainMap( const in vec3 pos ) {\n\treturn pos.y - terrainMed(pos.xz);  \n}\n\nfloat terrainMapH( const in vec3 pos ) {\n    float y = terrainHigh(pos.xz);\n    float h = pos.y - y;\n    return h;\n}\n\nfloat terrainIntersect( in vec3 ro, in vec3 rd, in float tmin, in float tmax ) {\n    float t = tmin;\n\tfor( int i=0; i<TERRAIN_NUM_STEPS; i++ ) {\n        vec3 pos = ro + t*rd;\n        float res = terrainMap( pos );\n        if( res<(0.001*t) || t>tmax  ) break;\n        t += res*.9;\n\t}\n\n\treturn t;\n}\n\nfloat terrainCalcShadow(in vec3 ro, in vec3 rd ) {\n\tvec2  eps = vec2(150.0,0.0);\n    float h1 = terrainMed( ro.xz );\n    float h2 = terrainLow( ro.xz );\n    \n    float d1 = 10.0;\n    float d2 = 80.0;\n    float d3 = 200.0;\n    float s1 = clamp( 1.0*(h1 + rd.y*d1 - terrainMed(ro.xz + d1*rd.xz)), 0.0, 1.0 );\n    float s2 = clamp( 0.5*(h1 + rd.y*d2 - terrainMed(ro.xz + d2*rd.xz)), 0.0, 1.0 );\n    float s3 = clamp( 0.2*(h2 + rd.y*d3 - terrainLow(ro.xz + d3*rd.xz)), 0.0, 1.0 );\n\n    return min(min(s1,s2),s3);\n}\nvec3 terrainCalcNormalHigh( in vec3 pos, float t ) {\n    vec2 e = vec2(1.0,-1.0)*0.001*t;\n\n    return normalize( e.xyy*terrainMapH( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*terrainMapH( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*terrainMapH( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*terrainMapH( pos + e.xxx ) );\n}\n\nvec3 terrainCalcNormalMed( in vec3 pos, float t ) {\n\tfloat e = 0.005*t;\n    vec2  eps = vec2(e,0.0);\n    float h = terrainMed( pos.xz );\n    return normalize(vec3( terrainMed(pos.xz-eps.xy)-h, e, terrainMed(pos.xz-eps.yx)-h ));\n}\n\nvec3 terrainTransform( in vec3 x ) {\n    x.zy = rotate( -.83, x.zy );\n    return x;\n}\n\nvec3 terrainUntransform( in vec3 x ) {\n    x.zy = rotate( .83, x.zy );\n    return x;\n}\n\n\nfloat llamelTime;\nconst float llamelScale = 5.;\n\nvec3 llamelPosition() {\n    llamelTime = time*2.5;\n    vec2 pos = vec2( -400., 135.-llamelTime*0.075* llamelScale);\n    return vec3( pos.x, terrainMed( pos ), pos.y );\n}\n\nvec3 terrainShade( const in vec3 col, const in vec3 pos, const in vec3 rd, const in vec3 n, const in float spec, \n                   const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n\tvec3 sunDirection =  terrainTransform(SUN_DIRECTION);\n    float dif = diffuse( n, sunDirection );\n    float bac = diffuse( n, vec3(-sunDirection.x, sunDirection.y, -sunDirection.z) );\n    float sha = terrainCalcShadow( pos, sunDirection );\n    float amb = clamp( n.y,0.0,1.0);\n        \n    vec3 lin  = vec3(0.0);\n    lin += 2.*dif*sunc*vec3( sha, sha*sha*0.1+0.9*sha, sha*sha*0.2+0.8*sha );\n    lin += 0.2*amb*upc;\n    lin += 0.08*bac*clamp(vec3(1.)-sunc, vec3(0.), vec3(1.));\n    return mix( col*lin*3., reflc, spec*fresnel(n,-terrainTransform(rd),5.0) );\n}\n\nvec3 terrainGetColor( const in vec3 pos, const in vec3 rd, const in float t, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n    vec3 nor = terrainCalcNormalHigh( pos, t );\n    vec3 sor = terrainCalcNormalMed( pos, t );\n        \n    float spec = 0.005;\n\n#ifdef DISPLAY_TERRAIN_DETAIL\n    float no = noise(5.*fbm(1.11*pos.xz));\n#else\n    const float no = 0.;\n#endif\n    float r = .5+.5*fbm(.95*pos.xz);\n\tvec3 col = (r*0.25+0.75)*0.9*mix( vec3(0.08,0.07,0.07), vec3(0.10,0.09,0.08), noise(0.4267*vec2(pos.x*2.,pos.y*9.8))+.01*no );\n    col = mix( col, 0.20*vec3(0.45,.30,0.15)*(0.50+0.50*r),smoothstep(0.825,0.925,nor.y+.025*no) );\n\tcol = mix( col, 0.15*vec3(0.30,.30,0.10)*(0.25+0.75*r),smoothstep(0.95,1.0,nor.y+.025*no) );\n    col *= .88+.12*no;\n        \n    float s = nor.y + 0.03*pos.y + 0.35*fbm(0.05*pos.xz) - .35;\n    float sf = fwidth(s) * 1.5;\n    s = smoothstep(0.84-sf, 0.84+sf, s );\n    col = mix( col, 0.29*vec3(0.62,0.65,0.7), s);\n    nor = mix( nor, sor, 0.7*smoothstep(0.9, 0.95, s ) );\n    spec = mix( spec, 0.45, smoothstep(0.9, 0.95, s ) );\n\n   \tcol = terrainShade( col, pos, rd, nor, spec, sunc, upc, reflc );\n\n#ifdef DISPLAY_LLAMEL\n    col *= clamp( distance(pos.xz, llamelPosition().xz )*0.4, 0.4, 1.);\n#endif\n    \n    return col;\n}\n\nvec3 terrainTransformRo( const in vec3 ro ) {\n    vec3 rom = terrainTransform(ro);\n    rom.y -= EARTH_RADIUS - 100.;\n    rom.xz *= 5.;\n    rom.xz += vec2(-170.,50.)+vec2(-4.,.4)*time;    \n    rom.y += (terrainLow( rom.xz ) - 86.)*clamp( 1.-1.*(length(ro)-EARTH_RADIUS), 0., 1.);\n    return rom;\n}\n\nvec4 renderTerrain( const in vec3 ro, const in vec3 rd, inout vec3 intersection, inout vec3 n ) {    \n    vec3 p,\n    rom = terrainTransformRo(ro),\n    rdm = terrainTransform(rd);\n        \n    float tmin = 10.0;\n    float tmax = 3200.0;\n    \n    float res = terrainIntersect( rom, rdm, tmin, tmax );\n    \n    if( res > tmax ) {\n        res = -1.;\n    } else {\n        vec3 pos =  rom+rdm*res;\n        n = terrainCalcNormalMed( pos, res );\n        n = terrainUntransform( n );\n        \n        intersection = ro+rd*res/100.;\n    }\n    return vec4(res, rom+rdm*res);\n}\n\n#endif\n\n//-----------------------------------------------------\n// LLamels by Eiffie\n//\n// https://www.shadertoy.com/view/ltsGz4\n//-----------------------------------------------------\n#ifdef DISPLAY_LLAMEL\nfloat llamelMapSMin(const in float a,const in float b,const in float k){\n    float h=clamp(0.5+0.5*(b-a)/k,0.0,1.0);return b+h*(a-b-k+k*h);\n}\n\nfloat llamelMapLeg(vec3 p, vec3 j0, vec3 j3, vec3 l, vec4 r, vec3 rt){//z joint with tapered legs\n\tfloat lx2z=l.x/(l.x+l.z),h=l.y*lx2z;\n\tvec3 u=(j3-j0)*lx2z,q=u*(0.5+0.5*(l.x*l.x-h*h)/dot(u,u));\n\tq+=sqrt(max(0.0,l.x*l.x-dot(q,q)))*normalize(cross(u,rt));\n\tvec3 j1=j0+q,j2=j3-q*(1.0-lx2z)/lx2z;\n\tu=p-j0;q=j1-j0;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\tfloat d=length(u-q*h)-r.x-(r.y-r.x)*h;\n\tu=p-j1;q=j2-j1;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\td=min(d,length(u-q*h)-r.y-(r.z-r.y)*h);\n\tu=p-j2;q=j3-j2;\n\th=clamp(dot(u,q)/dot(q,q),0.0,1.0);\n\treturn min(d,length(u-q*h)-r.z-(r.w-r.z)*h);\n}\n\nfloat llamelMap(in vec3 p) {\n\tconst vec3 rt=vec3(0.0,0.0,1.0);\t\n\tp.y += 0.25*llamelScale;\n    p.xz -= 0.5*llamelScale;\n    p.xz = vec2(-p.z, p.x);\n    vec3 pori = p;\n        \n    p /= llamelScale;\n    \n\tvec2 c=floor(p.xz);\n\tp.xz=fract(p.xz)-vec2(0.5);\n    p.y -= p.x*.04*llamelScale;\n\tfloat sa=sin(c.x*2.0+c.y*4.5+llamelTime*0.05)*0.15;\n\n    float b=0.83-abs(p.z);\n\tfloat a=c.x+117.0*c.y+sign(p.x)*1.57+sign(p.z)*1.57+llamelTime,ca=cos(a);\n\tvec3 j0=vec3(sign(p.x)*0.125,ca*0.01,sign(p.z)*0.05),j3=vec3(j0.x+sin(a)*0.1,max(-0.25+ca*0.1,-0.25),j0.z);\n\tfloat dL=llamelMapLeg(p,j0,j3,vec3(0.08,0.075,0.12),vec4(0.03,0.02,0.015,0.01),rt*sign(p.x));\n\tp.y-=0.03;\n\tfloat dB=(length(p.xyz*vec3(1.0,1.75,1.75))-0.14)*0.75;\n\ta=c.x+117.0*c.y+llamelTime;ca=cos(a);sa*=0.4;\n\tj0=vec3(0.125,0.03+abs(ca)*0.03,ca*0.01),j3=vec3(0.3,0.07+ca*sa,sa);\n\tfloat dH=llamelMapLeg(p,j0,j3,vec3(0.075,0.075,0.06),vec4(0.03,0.035,0.03,0.01),rt);\n\tdB=llamelMapSMin(min(dL,dH),dB,clamp(0.04+p.y,0.0,1.0));\n\ta=max(abs(p.z),p.y)+0.05;\n\treturn max(min(dB,min(a,b)),length(pori.xz-vec2(0.5)*llamelScale)-.5*llamelScale);\n}\n\nvec3 llamelGetNormal( in vec3 ro ) {\n    vec2 e = vec2(1.0,-1.0)*0.001;\n\n    return normalize( e.xyy*llamelMap( ro + e.xyy ) + \n\t\t\t\t\t  e.yyx*llamelMap( ro + e.yyx ) + \n\t\t\t\t\t  e.yxy*llamelMap( ro + e.yxy ) + \n\t\t\t\t\t  e.xxx*llamelMap( ro + e.xxx ) );\n}\n\nvec4 renderLlamel( in vec3 ro, const in vec3 rd, const in vec3 sunc, const in vec3 upc, const in vec3 reflc ) {\n    ro -= llamelPosition();\n\tfloat t=.1*hash(rd.xy),d,dm=10.0,tm;\n\tfor(int i=0;i<36;i++){\n\t\tt+=d=llamelMap(ro+rd*t);\n\t\tif(d<dm){dm=d;tm=t;}\n\t\tif(t>1000.0 || d<0.00001)break;\n\t}\n\tdm=max(0.0,dm);\n    if( dm < .02 ) {\n        vec3 col = vec3(0.45,.30,0.15)*.2;\n        vec3 pos = ro + rd*tm;\n        vec3 nor = llamelGetNormal( pos );\n        col = terrainShade( col, pos, rd, nor, .01, sunc, upc, reflc );        \n        return vec4(col, clamp( 1.-(dm-0.01)/0.01,0., 1.) );\n    }\n    \n    return vec4(0.);\n}\n#endif\n\n//-----------------------------------------------------\n// Clouds (by me ;))\n//-----------------------------------------------------\n\nvec4 renderClouds( const in vec3 ro, const in vec3 rd, const in float d, const in vec3 n, const in float land, \n                   const in vec3 sunColor, const in vec3 upColor, inout float shadow ) {\n\tvec3 intersection = ro+rd*d;\n    vec3 cint = intersection*0.009;\n    float rot = -.2*length(cint.xy) + .6*fbm( cint*.4,0.5,2.96 ) + .05*land;\n\n    cint.xy = rotate( rot, cint.xy );\n\n    vec3 cdetail = mod(intersection*3.23,vec3(50.));\n    cdetail.xy = rotate( .25*rot, cdetail.xy );\n\n    float clouds = 1.3*(fbm( cint*(1.+.02*noise(intersection)),0.5,2.96)+.4*land-.3);\n\n#ifdef DISPLAY_CLOUDS_DETAIL\n    if( d < 200. ) {\n        clouds += .3*(fbm(cdetail,0.5,2.96)-.5)*(1.-smoothstep(0.,200.,d));\n    }\n#endif\n\n    shadow = clamp(1.-clouds, 0., 1.);\n\n    clouds = clamp(clouds, 0., 1.);\n    clouds *= clouds;\n    clouds *= smoothstep(0.,0.4,d);\n\n    vec3 clbasecolor = vec3(1.);\n    vec3 clcol = .1*clbasecolor*sunColor * vec3(specular(n,SUN_DIRECTION,rd,36.0));\n    clcol += .3*clbasecolor*sunColor;\n    clcol += clbasecolor*(diffuse(n,SUN_DIRECTION)*sunColor+upColor);  \n    \n    return vec4( clcol, clouds );\n}\n\n//-----------------------------------------------------\n// Planet (by me ;))\n//-----------------------------------------------------\n\nvec4 renderPlanet( const in vec3 ro, const in vec3 rd, const in vec3 up, inout float maxd ) {\n    float d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS ) );\n\n    vec3 intersection = ro + rd*d;\n    vec3 n = nSphere( intersection, vec4( 0., 0., 0., EARTH_RADIUS ) );\n    vec4 res;\n\n#ifndef HIDE_TERRAIN\n    bool renderTerrainDetail = length(ro) < EARTH_RADIUS+EARTH_ATMOSPHERE && \n        \t\t\t\t\t   dot( terrainUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9996;\n#endif\n    bool renderSeaDetail     = d < 1. && dot( seaUntransform( vec3(0.,1.,0.) ), normalize(ro) ) > .9999; \n    float mixDetailColor = 0.;\n        \n\tif( d < 0. || d > maxd) {\n#ifndef HIDE_TERRAIN\n        if( renderTerrainDetail ) {\n       \t\tintersection = ro;\n            n = normalize( ro );\n        } else { \t       \n\t        return vec4(0);\n        }\n#else \n      \treturn vec4(0.);\n#endif\n\t}\n    if( d > 0. ) {\n\t    maxd = d;\n    }\n    float att = 0.;\n    \n    if( dot(n,SUN_DIRECTION) < -0.1 ) return vec4( 0., 0., 0., 1. );\n    \n    float dm = MAX, e = 0.;\n    vec3 col, detailCol, nDetail;\n    \n    // normal and intersection \n#ifndef HIDE_TERRAIN\n    if( renderTerrainDetail ) {   \n        res = renderTerrain( ro, rd, intersection, nDetail );\n        if( res.x < 0. && d < 0. ) {\n\t        return vec4(0);\n        }\n        if( res.x >= 0. ) {\n            maxd = pow(res.x/4000.,4.)*50.;\n            e = -10.;\n        }\n        mixDetailColor = 1.-smoothstep(.75, 1., (length(ro)-EARTH_RADIUS) / EARTH_ATMOSPHERE);\n        n = normalize( mix( n, nDetail, mixDetailColor ) );\n    } else \n#endif        \n    if( renderSeaDetail ) {    \n        float attsea, mf = smoothstep(.5,1.,d);\n\n        renderSea( ro, rd, nDetail, attsea );\n\n        n = normalize(mix( nDetail, n, mf ));\n        att = mix( attsea, att, mf );\n    } else {\n        e = fbm( .003*intersection+vec3(1.),0.4,2.96) + smoothstep(.85,.95, abs(intersection.z/EARTH_RADIUS));\n#ifndef HIDE_TERRAIN\n        if( d < 1500. ) {\n            e += (-.03+.06* fbm( intersection*0.1,0.4,2.96))*(1.-d/1500.);\n        }\n#endif  \n    }\n    \n    vec3 sunColor = .25*renderAtmosphericLow( intersection, SUN_DIRECTION).xyz;  \n    vec3 upColor = 2.*renderAtmosphericLow( intersection, n).xyz;  \n    vec3 reflColor = renderAtmosphericLow( intersection, reflect(rd,n)).xyz; \n                 \n    // color  \n#ifndef HIDE_TERRAIN\n    if(renderTerrainDetail ) {\n        detailCol = col =  terrainGetColor(res.yzw, rd, res.x, sunColor, upColor, reflColor);\n\t\td = 0.;\n    }   \n#endif\n     \n    if( mixDetailColor < 1. ) {\n        if( e < .45 ) {\n            // sea\n            col = seaGetColor(n,rd,SUN_DIRECTION, att, sunColor, upColor, reflColor);    \n        } else {\n            // planet (land) far\n            float land1 = max(0.1, fbm( intersection*0.0013,0.4,2.96) );\n            float land2 = max(0.1, fbm( intersection*0.0063,0.4,2.96) );\n            float iceFactor = abs(pow(intersection.z/EARTH_RADIUS,13.0))*e;\n\n            vec3 landColor1 = vec3(0.43,0.65,0.1) * land1;\n            vec3 landColor2 = RING_COLOR_1 * land2;\n            vec3 mixedLand = (landColor1 + landColor2)* 0.5;\n            vec3 finalLand = mix(mixedLand, vec3(7.0, 7.0, 7.0) * land1 * 1.5, max(iceFactor+.02*land2-.02, 0.));\n\n            col = (diffuse(n,SUN_DIRECTION)*sunColor+upColor)*finalLand*.75;\n#ifdef HIGH_QUALITY\n            col *= (.5+.5*fbm( intersection*0.23,0.4,2.96) );\n#endif\n        }\n    }\n    \n    if( mixDetailColor > 0. ) {\n        col = mix( col, detailCol, mixDetailColor );\n    }\n        \n#ifdef DISPLAY_LLAMEL\n    if(renderTerrainDetail ) {\n        vec3 rom = terrainTransformRo(ro),\n        rdm = terrainTransform(rd);\n        d = iSphere( rom, rdm, vec4( llamelPosition(), llamelScale*3. ) );\n        if( d > 0. ) {\n            vec4 llamel = renderLlamel( rom+rdm*d, rdm, sunColor, upColor, reflColor );\n            col = mix(col, llamel.rgb, llamel.a);\n        }\n    }\n#endif\n    \n    d = iSphere( ro, rd, vec4( 0., 0., 0., EARTH_RADIUS+EARTH_CLOUDS ) );\n    if( d > 0. ) { \n        float shadow;\n\t\tvec4 clouds = renderClouds( ro, rd, d, n, e, sunColor, upColor, shadow);\n        col *= shadow; \n        col = mix( col, clouds.rgb, clouds.w );\n    }\n    \n    float m = MAX;\n    col *= (1. - renderRingFarShadow( ro+rd*d, SUN_DIRECTION ) );\n\n \treturn vec4( col, 1. ); \n}\n\n//-----------------------------------------------------\n// Lens flare by musk\n//\n// https://www.shadertoy.com/view/4sX3Rs\n//-----------------------------------------------------\n\nvec3 lensFlare( const in vec2 uv, const in vec2 pos) {\n\tvec2 main = uv-pos;\n\tvec2 uvd = uv*(length(uv));\n\t\n\tfloat f0 = 1.5/(length(uv-pos)*16.0+1.0);\n\t\n\tfloat f1 = max(0.01-pow(length(uv+1.2*pos),1.9),.0)*7.0;\n\n\tfloat f2 = max(1.0/(1.0+32.0*pow(length(uvd+0.8*pos),2.0)),.0)*00.25;\n\tfloat f22 = max(1.0/(1.0+32.0*pow(length(uvd+0.85*pos),2.0)),.0)*00.23;\n\tfloat f23 = max(1.0/(1.0+32.0*pow(length(uvd+0.9*pos),2.0)),.0)*00.21;\n\t\n\tvec2 uvx = mix(uv,uvd,-0.5);\n\t\n\tfloat f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n\tfloat f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n\tfloat f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\t\n\tvec3 c = vec3(.0);\n\t\n\tc.r+=f2+f4; c.g+=f22+f42; c.b+=f23+f43;\n\tc = c*.5 - vec3(length(uvd)*.05);\n\tc+=vec3(f0);\n\t\n\treturn c;\n}\n\n//-----------------------------------------------------\n// cameraPath\n//-----------------------------------------------------\n\nvec3 pro, pta, pup;\nfloat dro, dta, dup;\n\nvoid camint( inout vec3 ret, const in float t, const in float duration, const in vec3 dest, inout vec3 prev, inout float prevt ) {\n    if( t >= prevt && t <= prevt+duration ) {\n    \tret = mix( prev, dest, smoothstep(prevt, prevt+duration, t) );\n    }\n    prev = dest;\n    prevt += duration;\n}\n\nvoid cameraPath( in float t, out vec3 ro, out vec3 ta, out vec3 up ) {\n#ifndef HIDE_TERRAIN\n    time = t = mod( t, 92. );\n#else\n    time = t = mod( t, 66. );\n#endif\n    dro = dta = dup = 0.;\n\n    pro = ro = vec3(900. ,7000. ,1500. );\n    pta = ta = vec3(    0. ,    0. ,   0. );\n    pup = up = vec3(    0. ,    0.4,   1. ); \n   \n    camint( ro, t, 5., vec3(-4300. ,-1000. , 500. ), pro, dro );\n    camint( ta, t, 5., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 7., vec3(    0. ,    0.1,   1. ), pup, dup ); \n \n    camint( ro, t, 3., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 1., vec3(    0. , 300. ,-600. ), pta, dta );\n    camint( up, t, 6., vec3(    0. ,  0.1,    1. ), pup, dup );\n\n    camint( ro, t, 10., vec3(-1355. , 1795. , 1.2 ), pro, dro );\n    camint( ta, t, 14., vec3(    0. , 100. ,   600. ), pta, dta );\n    camint( up, t, 13., vec3(    0. ,  0.3,    1. ), pup, dup );\n    \n    vec3 roe = seaUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\n    vec3 upe = seaUntransform( vec3( 0., 1., 0. ) );\n    \n    camint( ro, t, 7.,roe, pro, dro );\n    camint( ta, t, 7., vec3( EARTH_RADIUS + 0., EARTH_RADIUS - 500., 500. ), pta, dta );\n    camint( up, t, 6., upe, pup, dup );\n        \n    camint( ro, t, 17.,roe, pro, dro );\n    camint( ta, t, 17., vec3( EARTH_RADIUS + 500., EARTH_RADIUS + 1300., -100. ), pta, dta );\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\n    \n    camint( ro, t, 11., vec3(  3102. ,  0. , 1450. ), pro, dro );\n    camint( ta, t, 4., vec3(    0. ,   -100. ,   0. ), pta, dta );\n    camint( up, t, 8., vec3(    0. ,    0.15,   1. ), pup, dup ); \n#ifndef HIDE_TERRAIN    \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.004, 0. ) );\n    upe = terrainUntransform( vec3( 0., 1., 0. ) );\n    \n    camint( ro, t, 7., roe, pro, dro );\n    camint( ta, t, 12., vec3( -EARTH_RADIUS, EARTH_RADIUS+200., 100.), pta, dta );\n    camint( up, t, 2., upe, pup, dup );\n        \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+0.001, 0. ) );\n    camint( ro, t, 17.,roe, pro, dro );\n    camint( ta, t, 18., roe + vec3( 5000., EARTH_RADIUS-100., -2000.), pta, dta );\n    camint( up, t, 18., vec3(.0,1.,1.), pup, dup );\n        \n    roe = terrainUntransform( vec3( 0., EARTH_RADIUS+1.8, 0. ) );\n    camint( ro, t, 4.,roe, pro, dro );\n    camint( ta, t, 4.5, roe + vec3( EARTH_RADIUS, EARTH_RADIUS+2000., -30.), pta, dta );\n    camint( up, t, 4., vec3(.0,1.,1.), pup, dup );\n#endif    \n    camint( ro, t, 10., vec3(900. ,7000. , 1500. ), pro, dro );\n    camint( ta, t, 2., vec3(    0. ,    0. ,   0. ), pta, dta );\n    camint( up, t, 10., vec3(    0. ,    0.4,   1. ), pup, dup ); \n    \n    up = normalize( up );\n}\n\n//-----------------------------------------------------\n// mainImage\n//-----------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 p = -1.0 + 2.0 * (fragCoord.xy) / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 col;\n    \n// black bands\n    vec2 bandy = vec2(.1,.9);\n    if( uv.y < bandy.x || uv.y > bandy.y ) {\n        col = vec3(0.);\n    } else {\n        // camera\n        vec3 ro, ta, up;\n        cameraPath( iTime*.7, ro, ta, up );\n\n        vec3 ww = normalize( ta - ro );\n        vec3 uu = normalize( cross(ww,up) );\n        vec3 vv = normalize( cross(uu,ww));\n        vec3 rd = normalize( -p.x*uu + p.y*vv + 2.2*ww );\n\n        float maxd = MAX;  \n        col = renderStars( rd ).xyz;\n\n        vec4 planet = renderPlanet( ro, rd, up, maxd );       \n        if( planet.w > 0. ) col.xyz = planet.xyz;\n\n        float atmosphered = maxd;\n        vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n        col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n        vec4 ring = renderRing( ro, rd, maxd );\n        if( ring.w > 0. && atmosphered < maxd ) {\n           ring.xyz = ring.xyz * (1.-atmosphere.w ) + atmosphere.xyz; \n        }\n        col = col * (1.-ring.w ) + ring.xyz;\n\n#ifdef DISPLAY_CLOUDS\n        float lro = length(ro);\n        if( lro < EARTH_RADIUS+EARTH_CLOUDS*1.25 ) {\n            vec3 sunColor = 2.*renderAtmosphericLow( ro, SUN_DIRECTION);  \n            vec3 upColor = 4.*renderAtmosphericLow( ro, vec3(-SUN_DIRECTION.x, SUN_DIRECTION.y, -SUN_DIRECTION.z));  \n\n            if( lro < EARTH_RADIUS+EARTH_CLOUDS ) {\n                // clouds\n                float d = iCSphereF( ro, rd, EARTH_RADIUS + EARTH_CLOUDS );\n                if( d < maxd ) {\n                    float shadow;\n                    vec4 clouds = renderClouds( ro, rd, d, normalize(ro), 0., sunColor, upColor, shadow );\n                    clouds.w *= 1.-smoothstep(0.8*EARTH_CLOUDS,EARTH_CLOUDS,lro-EARTH_RADIUS);\n                    col = mix(col, clouds.rgb, clouds.w * (1.-smoothstep( 10., 30., d)) );\n                }\n            }\n            float offset = lro-EARTH_RADIUS-EARTH_CLOUDS;\n            col = mix( col, .5*sunColor, .15*abs(noise(offset*100.))*clamp(1.-4.*abs(offset)/EARTH_CLOUDS, 0., 1.) );\n        }\n#endif \n\n        // post processing\n        col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n        col *= vec3(1.,0.99,0.95);   \n        col = clamp(1.06*col-0.03, 0., 1.);      \n\n        vec2 sunuv =  2.7*vec2( dot( SUN_DIRECTION, -uu ), dot( SUN_DIRECTION, vv ) );\n        float flare = dot( SUN_DIRECTION, normalize(ta-ro) );\n        col += vec3(1.4,1.2,1.0)*lensFlare(p, sunuv)*clamp( flare+.3, 0., 1.);\n\n        uv.y = (uv.y-bandy.x)*(1./(bandy.y-bandy.x));\n        col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 ); \n    }\n    fragColor = vec4( col ,1.0);\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 ro, in vec3 rd ) {\n    float maxd = MAX;  \n    time = iTime * .7;\n    \n    rd = rd.xzy;\n    ro = (ro.xzy * .1) + vec3(-1355. , 1795. , 1. );\n    \n    vec3 col = renderStars( rd ).xyz;\n\n    vec4 planet = renderPlanet( ro, rd, vec3(0,.1,1), maxd );       \n    if( planet.w > 0. ) col.xyz = planet.xyz;\n\n    float atmosphered = maxd;\n    vec4 atmosphere = .85*renderAtmospheric( ro, rd, atmosphered );\n    col = col * (1.-atmosphere.w ) + atmosphere.xyz; \n\n    vec4 ring = renderRing( ro, rd, maxd );\n    col = col * (1.-ring.w ) + ring.xyz;\n    \n    // post processing\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    col *= vec3(1.,0.99,0.95);   \n    col = clamp(1.06*col-0.03, 0., 1.);      \n    fragColor = vec4( col ,1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [],
                "outputs": [
                    {
                        "id": 38,
                        "channel": 0
                    }
                ],
                "code": "\n//----------------------------------------------------------------------\n// Wind function by Dave Hoskins https://www.shadertoy.com/view/4ssXW2\n\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453123);\n}\nvec2 Hash( vec2 p) {\n    return vec2( hash(p.x), hash(p.y) );\n}\n\n//--------------------------------------------------------------------------\nvec2 Noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 res = mix(mix( Hash(p + 0.0), Hash(p + vec2(1.0, 0.0)),f.x),\n                   mix( Hash(p + vec2(0.0, 1.0) ), Hash(p + vec2(1.0, 1.0)),f.x),f.y);\n    return res-.5;\n}\n\n//--------------------------------------------------------------------------\nvec2 FBM( vec2 p ) {\n    vec2 f;\n\tf  = 0.5000\t * Noise(p); p = p * 2.32;\n\tf += 0.2500  * Noise(p); p = p * 2.23;\n\tf += 0.1250  * Noise(p); p = p * 2.31;\n    f += 0.0625  * Noise(p); p = p * 2.28;\n    f += 0.03125 * Noise(p);\n    return f;\n}\n\n//--------------------------------------------------------------------------\nvec2 Wind(float n) {\n    vec2 pos = vec2(n * (162.017331), n * (132.066927));\n    vec2 vol = Noise(vec2(n*23.131, -n*42.13254))*1.0 + 1.0;\n    \n    vec2 noise = vec2(FBM(pos*33.313))* vol.x *.5 + vec2(FBM(pos*4.519)) * vol.y;\n    \n\treturn noise;\n}\n\n//----------------------------------------------------------------------\n\n\n\nvec2 mainSound(float time) {\n    //16 - 38\n //   time -= 7.5;\n    time *= .7;\n    float vol = 1.-smoothstep(6.,8.5, time);\n    vol += smoothstep(16.5,20., time);\n    vol *= 1.-smoothstep(23.5,25.5, time);\n    vol += smoothstep(47.5,51.5, time);\n    vol = vol*.8+.2;\n    \n\treturn Wind(time*.05) * vol;\n}",
                "name": "Sound",
                "description": "",
                "type": "sound"
            }
        ]
    }
}