{
    "Shader": {
        "info": {
            "date": "1547542000",
            "description": "Fast Approximate Median Filter with Adaptive Quantization\n(click to reveal original input)",
            "flags": 0,
            "hasliked": 0,
            "id": "WdX3Wj",
            "likes": 1,
            "name": "fastMedian",
            "published": 3,
            "tags": [
                "fast",
                "filter",
                "post",
                "effect",
                "median"
            ],
            "username": "and",
            "viewed": 175
        },
        "renderpass": [
            {
                "code": "// fastMedian\n//\n// Somewhat inspired by Oilify effect in oilArt shader\n// https://www.shadertoy.com/view/lsKGDW\n//\n// Once in a while there is a need to perform median filtering in\n// real-time at high frame rate on the GPU. Exact solution can be\n// quite complicated and involves array sorting.\n// However, if the exact solution is not needed, it is possible\n// to estimate median using histogram only. Also, it turns out\n// that you can get away with relatively low bin count if histogram\n// is built knowing minimum and maximum values upfront via pre-pass.\n//\n// In real-world applications when shared/thread local storage\n// is available such histogram calculation is trivial. In this\n// shader due to WebGL limitations the inner loop is unrolled.\n//\n// Created by Dmitry Andreev - and'2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define RADIUS 2 //  5x5\n#define RADIUS 4 //  9x9\n//#define RADIUS 6 // 13x13\n\n#define ADAPTIVE_QUANTIZATION\n\n//#define BIN_COUNT 4\n//#define BIN_COUNT 8\n#define BIN_COUNT 12\n//#define BIN_COUNT 24\n//#define BIN_COUNT 48\n\n//\n\n#if BIN_COUNT == 4\n\t#define UNROLL(X) X(0)X(1)X(2)X(3)\n\n#elif BIN_COUNT == 8\n\t#define UNROLL(X) X(0)X(1)X(2)X(3)X(4)X(5)X(6)X(7)\n\n#elif BIN_COUNT == 12\n\t#define UNROLL(X) X(0)X(1)X(2)X(3)X(4)X(5)X(6)X(7)X(8)X(9)X(10)X(11)\n\n#elif BIN_COUNT == 24\n\t#define U00_11(X) X(0)X(1)X(2)X(3)X(4)X(5)X(6)X(7)X(8)X(9)X(10)X(11)\n\t#define U12_23(X) X(12)X(13)X(14)X(15)X(16)X(17)X(18)X(19)X(20)X(21)X(22)X(23)\n\t#define UNROLL(X) U00_11(X)U12_23(X)\n            \n#elif BIN_COUNT == 48\n\t#define U00_11(X) X(0)X(1)X(2)X(3)X(4)X(5)X(6)X(7)X(8)X(9)X(10)X(11)\n\t#define U12_23(X) X(12)X(13)X(14)X(15)X(16)X(17)X(18)X(19)X(20)X(21)X(22)X(23)\n\t#define U24_35(X) X(24)X(25)X(26)X(27)X(28)X(29)X(30)X(31)X(32)X(33)X(34)X(35)\n\t#define U36_47(X) X(36)X(37)X(38)X(39)X(40)X(41)X(42)X(43)X(44)X(45)X(46)X(47)\n\t#define UNROLL(X) U00_11(X)U12_23(X)U24_35(X)U36_47(X)\n            \n#endif\n\nvec3 readInput(vec2 uv, int dx, int dy)\n{\n    // Force nearest sampling for demonstration purposes\n    vec2 img_res = iChannelResolution[0].xy;\n    uv = (0.5 + floor(uv * img_res)) / img_res;\n    \n\treturn texture(iChannel0, uv + vec2(dx, dy) / img_res, -10.0).rgb;\n}\n\n//\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Fit image to touch screen from outside\n    vec2 img_res = iChannelResolution[0].xy;\n    vec2 res = iResolution.xy / img_res;\n    vec2 img_size = img_res * max(res.x, res.y);\n    vec2 img_org = 0.5 * (iResolution.xy - img_size);\n    vec2 uv = (fragCoord - img_org) / img_size;\n\n    vec3 ocol = readInput(uv, 0, 0);\n    vec3 col = ocol;\n    \n    const int r = RADIUS;\n    \n\tvec4 bins[BIN_COUNT];\n\t#define INIT(n) bins[n] = vec4(0);\n    UNROLL(INIT)\n\n#ifdef ADAPTIVE_QUANTIZATION        \n\tfloat vmin = 1.0;\n\tfloat vmax = 0.0;\n\n\tfor (int y = -r; y <= r; y++)\n\tfor (int x = -r; x <= r; x++)\n\t{\n        vec3 img = readInput(uv, x, y);\n\t\tfloat v = (img.r + img.g + img.b) / 3.0;\n\n\t\tvmin = min(vmin, v);\n\t\tvmax = max(vmax, v);\n\t}\n    \n#else\n   \tfloat vmin = 0.0;\n\tfloat vmax = 1.0;\n    \n#endif\n\n\tfor (int y = -r; y <= r; y++)\n\tfor (int x = -r; x <= r; x++)\n\t{\n        vec3 img = readInput(uv, x, y);\n\t\tfloat v = (img.r + img.g + img.b) / 3.0;\n\n\t\tint i = int(0.5 + ((v - vmin) / (vmax - vmin)) * float(BIN_COUNT));\n\n\t\t#define UPDATE(n) if (i == n) bins[n] += vec4(img.rgb, 1.0);\n        UNROLL(UPDATE)\n\t}\n    \n\tfloat mid = floor((float(r * 2 + 1) * float(r * 2 + 1)) / 2.0);\n\tfloat pos = 0.0;\n\n    #define M1(i) col.rgb = pos <= mid && bins[i].a > 0.0 ?\n    #define M2(i) bins[i].rgb / bins[i].aaa : col.rgb;\n    #define M3(i) pos += bins[i].a;\n    #define MEDIAN(i) M1(i)M2(i)M3(i)\n    UNROLL(MEDIAN)\n\n    // Show original image on click\n    if (iMouse.w > 0.0) col = ocol;\n        \n    fragColor = vec4(col, 1.0);\n}",
                "description": "",
                "filename": "fastMedian-Image.frag",
                "inputs": [
                    {
                        "channel": 0,
                        "ctype": "video",
                        "id": 29,
                        "published": 1,
                        "sampler": {
                            "filter": "linear",
                            "internal": "byte",
                            "srgb": "false",
                            "vflip": "true",
                            "wrap": "clamp"
                        },
                        "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv"
                    }
                ],
                "name": "Image",
                "outputs": [
                    {
                        "channel": 0,
                        "id": 37
                    }
                ],
                "type": "image"
            }
        ],
        "ver": "0.1"
    }
}
