{
    "Shader": {
        "ver": "0.1",
        "info": {
            "id": "XlBSRz",
            "date": "1440854078",
            "viewed": 21345,
            "name": "VolumetricIntegration",
            "username": "SebH",
            "description": "A volumetric rendering demo.\nThis shader also presents the advantage of integrating analytically the scattered light within participating media having high scattering value.",
            "likes": 297,
            "published": 3,
            "flags": 0,
            "tags": [
                "volumetric",
                "integration",
                "participatingmedia"
            ],
            "hasliked": 0
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": 15,
                        "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png",
                        "ctype": "texture",
                        "channel": 0,
                        "sampler": {
                            "filter": "mipmap",
                            "wrap": "repeat",
                            "vflip": "false",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": 37,
                        "channel": 0
                    }
                ],
                "code": "/* Hi there!\n * Here is a demo presenting volumetric rendering single with shadowing.\n * Did it quickly so I hope I have not made any big mistakes :)\n *\n * I also added the improved scattering integration I propose in my SIGGRAPH'15 presentation\n * about Frostbite new volumetric system I have developed. See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n * Basically it improves the scattering integration for each step with respect to extinction\n * The difference is mainly visible for some participating media having a very strong scattering value. \n * I have setup some pre-defined settings for you to checkout below (to present the case it improves):\n * - D_DEMO_SHOW_IMPROVEMENT_xxx: shows improvement (on the right side of the screen). You can still see aliasing due to volumetric shadow and the low amount of sample we take for it.\n * - D_DEMO_SHOW_IMPROVEMENT_xxx_NOVOLUMETRICSHADOW: same as above but without volumetric shadow\n *\n * To increase the volumetric rendering accuracy, I constrain the ray marching steps to a maximum distance.\n *\n * Volumetric shadows are evaluated by raymarching toward the light to evaluate transmittance for each view ray steps (ouch!)\n *\n * Do not hesitate to contact me to discuss about all that :) \n * SebH\n */\n\n\n\n/*\n * This are predefined settings you can quickly use\n *    - D_DEMO_FREE play with parameters as you would like\n *    - D_DEMO_SHOW_IMPROVEMENT_FLAT show improved integration on flat surface\n *    - D_DEMO_SHOW_IMPROVEMENT_NOISE show improved integration on noisy surface\n *    - the two previous without volumetric shadows\n */\n#define D_DEMO_FREE\n//#define D_DEMO_SHOW_IMPROVEMENT_FLAT\n//#define D_DEMO_SHOW_IMPROVEMENT_NOISE\n//#define D_DEMO_SHOW_IMPROVEMENT_FLAT_NOVOLUMETRICSHADOW\n//#define D_DEMO_SHOW_IMPROVEMENT_NOISE_NOVOLUMETRICSHADOW\n\n\n\n\n\n#ifdef D_DEMO_FREE\n\t// Apply noise on top of the height fog?\n    #define D_FOG_NOISE 1.0\n\n\t// Height fog multiplier to show off improvement with new integration formula\n    #define D_STRONG_FOG 0.0\n\n    // Enable/disable volumetric shadow (single scattering shadow)\n    #define D_VOLUME_SHADOW_ENABLE 1\n\n\t// Use imporved scattering?\n\t// In this mode it is full screen and can be toggle on/off.\n\t#define D_USE_IMPROVE_INTEGRATION 1\n\n//\n// Pre defined setup to show benefit of the new integration. Use D_DEMO_FREE to play with parameters\n//\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT)\n    #define D_STRONG_FOG 10.0\n    #define D_FOG_NOISE 0.0\n\t#define D_VOLUME_SHADOW_ENABLE 1\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE)\n    #define D_STRONG_FOG 5.0\n    #define D_FOG_NOISE 1.0\n\t#define D_VOLUME_SHADOW_ENABLE 1\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_FLAT_NOVOLUMETRICSHADOW)\n    #define D_STRONG_FOG 10.0\n    #define D_FOG_NOISE 0.0\n\t#define D_VOLUME_SHADOW_ENABLE 0\n#elif defined(D_DEMO_SHOW_IMPROVEMENT_NOISE_NOVOLUMETRICSHADOW)\n    #define D_STRONG_FOG 3.0\n    #define D_FOG_NOISE 1.0\n\t#define D_VOLUME_SHADOW_ENABLE 0\n#endif\n\n\n\n/*\n * Other options you can tweak\n */\n\n// Used to control wether transmittance is updated before or after scattering (when not using improved integration)\n// If 0 strongly scattering participating media will not be energy conservative\n// If 1 participating media will look too dark especially for strong extinction (as compared to what it should be)\n// Toggle only visible zhen not using the improved scattering integration.\n#define D_UPDATE_TRANS_FIRST 0\n\n// Apply bump mapping on walls\n#define D_DETAILED_WALLS 0\n\n// Use to restrict ray marching length. Needed for volumetric evaluation.\n#define D_MAX_STEP_LENGTH_ENABLE 1\n\n// Light position and color\n#define LPOS vec3( 20.0+15.0*sin(iTime), 15.0+12.0*cos(iTime),-20.0)\n#define LCOL (600.0*vec3( 1.0, 0.9, 0.5))\n\n\nfloat displacementSimple( vec2 p )\n{\n    float f;\n    f  = 0.5000* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.2500* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.1250* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    f += 0.0625* textureLod( iChannel0, p, 0.0 ).x; p = p*2.0;\n    \n    return f;\n}\n\n\nvec3 getSceneColor(vec3 p, float material)\n{\n\tif(material==1.0)\n\t{\n\t\treturn vec3(1.0, 0.5, 0.5);\n\t}\n\telse if(material==2.0)\n\t{\n\t\treturn vec3(0.5, 1.0, 0.5);\n\t}\n\telse if(material==3.0)\n\t{\n\t\treturn vec3(0.5, 0.5, 1.0);\n\t}\n\t\n\treturn vec3(0.0, 0.0, 0.0);\n}\n\n\nfloat getClosestDistance(vec3 p, out float material)\n{\n\tfloat d = 0.0;\n#if D_MAX_STEP_LENGTH_ENABLE\n    float minD = 1.0; // restrict max step for better scattering evaluation\n#else\n\tfloat minD = 10000000.0;\n#endif\n\tmaterial = 0.0;\n    \n    float yNoise = 0.0;\n    float xNoise = 0.0;\n    float zNoise = 0.0;\n#if D_DETAILED_WALLS\n    yNoise = 1.0*clamp(displacementSimple(p.xz*0.005),0.0,1.0);\n    xNoise = 2.0*clamp(displacementSimple(p.zy*0.005),0.0,1.0);\n    zNoise = 0.5*clamp(displacementSimple(p.xy*0.01),0.0,1.0);\n#endif\n    \n\td = max(0.0, p.y - yNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 2.0;\n\t}\n\t\n\td = max(0.0,p.x - xNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 1.0;\n\t}\n\t\n\td = max(0.0,40.0-p.x - xNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 1.0;\n\t}\n\t\n\td = max(0.0,-p.z - zNoise);\n\tif(d<minD)\n\t{\n\t\tminD = d;\n\t\tmaterial = 3.0;\n    }\n    \n\treturn minD;\n}\n\n\nvec3 calcNormal( in vec3 pos)\n{\n    float material = 0.0;\n    vec3 eps = vec3(0.3,0.0,0.0);\n\treturn normalize( vec3(\n           getClosestDistance(pos+eps.xyy, material) - getClosestDistance(pos-eps.xyy, material),\n           getClosestDistance(pos+eps.yxy, material) - getClosestDistance(pos-eps.yxy, material),\n           getClosestDistance(pos+eps.yyx, material) - getClosestDistance(pos-eps.yyx, material) ) );\n\n}\n\nvec3 evaluateLight(in vec3 pos)\n{\n    vec3 lightPos = LPOS;\n    vec3 lightCol = LCOL;\n    vec3 L = lightPos-pos;\n    return lightCol * 1.0/dot(L,L);\n}\n\nvec3 evaluateLight(in vec3 pos, in vec3 normal)\n{\n    vec3 lightPos = LPOS;\n    vec3 L = lightPos-pos;\n    float distanceToL = length(L);\n    vec3 Lnorm = L/distanceToL;\n    return max(0.0,dot(normal,Lnorm)) * evaluateLight(pos);\n}\n\n// To simplify: wavelength independent scattering and extinction\nvoid getParticipatingMedia(out float sigmaS, out float sigmaE, in vec3 pos)\n{\n    float heightFog = 7.0 + D_FOG_NOISE*3.0*clamp(displacementSimple(pos.xz*0.005 + iTime*0.01),0.0,1.0);\n    heightFog = 0.3*clamp((heightFog-pos.y)*1.0, 0.0, 1.0);\n    \n    const float fogFactor = 1.0 + D_STRONG_FOG * 5.0;\n    \n    const float sphereRadius = 5.0;\n    float sphereFog = clamp((sphereRadius-length(pos-vec3(20.0,19.0,-17.0)))/sphereRadius, 0.0,1.0);\n    \n    const float constantFog = 0.02;\n\n    sigmaS = constantFog + heightFog*fogFactor + sphereFog;\n   \n    const float sigmaA = 0.0;\n    sigmaE = max(0.000000001, sigmaA + sigmaS); // to avoid division by zero extinction\n}\n\nfloat phaseFunction()\n{\n    return 1.0/(4.0*3.14);\n}\n\nfloat volumetricShadow(in vec3 from, in vec3 to)\n{\n#if D_VOLUME_SHADOW_ENABLE\n    const float numStep = 16.0; // quality control. Bump to avoid shadow alisaing\n    float shadow = 1.0;\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    float dd = length(to-from) / numStep;\n    for(float s=0.5; s<(numStep-0.1); s+=1.0)// start at 0.5 to sample at center of integral part\n    {\n        vec3 pos = from + (to-from)*(s/(numStep));\n        getParticipatingMedia(sigmaS, sigmaE, pos);\n        shadow *= exp(-sigmaE * dd);\n    }\n    return shadow;\n#else\n    return 1.0;\n#endif\n}\n\nvoid traceScene(bool improvedScattering, vec3 rO, vec3 rD, inout vec3 finalPos, inout vec3 normal, inout vec3 albedo, inout vec4 scatTrans)\n{\n\tconst int numIter = 100;\n\t\n    float sigmaS = 0.0;\n    float sigmaE = 0.0;\n    \n    vec3 lightPos = LPOS;\n    \n    // Initialise volumetric scattering integration (to view)\n    float transmittance = 1.0;\n    vec3 scatteredLight = vec3(0.0, 0.0, 0.0);\n    \n\tfloat d = 1.0; // hack: always have a first step of 1 unit to go further\n\tfloat material = 0.0;\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n    float dd = 0.0;\n\tfor(int i=0; i<numIter;++i)\n\t{\n\t\tvec3 p = rO + d*rD;\n        \n        \n    \tgetParticipatingMedia(sigmaS, sigmaE, p);\n        \n#ifdef D_DEMO_FREE\n        if(D_USE_IMPROVE_INTEGRATION>0) // freedom/tweakable version\n#else\n        if(improvedScattering)\n#endif\n        {\n            // See slide 28 at http://www.frostbite.com/2015/08/physically-based-unified-volumetric-rendering-in-frostbite/\n            vec3 S = evaluateLight(p) * sigmaS * phaseFunction()* volumetricShadow(p,lightPos);// incoming light\n            vec3 Sint = (S - S * exp(-sigmaE * dd)) / sigmaE; // integrate along the current step segment\n            scatteredLight += transmittance * Sint; // accumulate and also take into account the transmittance from previous steps\n\n            // Evaluate transmittance to view independentely\n            transmittance *= exp(-sigmaE * dd);\n        }\n\t\telse\n        {\n            // Basic scatering/transmittance integration\n        #if D_UPDATE_TRANS_FIRST\n            transmittance *= exp(-sigmaE * dd);\n        #endif\n            scatteredLight += sigmaS * evaluateLight(p) * phaseFunction() * volumetricShadow(p,lightPos) * transmittance * dd;\n        #if !D_UPDATE_TRANS_FIRST\n            transmittance *= exp(-sigmaE * dd);\n        #endif\n        }\n        \n\t\t\n        dd = getClosestDistance(p, material);\n        if(dd<0.2)\n            break; // give back a lot of performance without too much visual loss\n\t\td += dd;\n\t}\n\t\n\talbedo = getSceneColor(p, material);\n\t\n    finalPos = rO + d*rD;\n    \n    normal = calcNormal(finalPos);\n    \n    scatTrans = vec4(scatteredLight, transmittance);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //iTime\n    //iMouse\n    //iResolution\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float hfactor = float(iResolution.y) / float(iResolution.x); // make it screen ratio independent\n\tvec2 uv2 = vec2(2.0, 2.0*hfactor) * fragCoord.xy / iResolution.xy - vec2(1.0, hfactor);\n\t\n\tvec3 camPos = vec3( 20.0, 18.0,-50.0);\n     if(iMouse.x+iMouse.y > 0.0) // to handle first loading and see somthing on screen\n        camPos += vec3(0.05,0.12,0.0)*(vec3(iMouse.x, iMouse.y, 0.0)-vec3(iResolution.xy*0.5, 0.0));\n\tvec3 camX   = vec3( 1.0, 0.0, 0.0);\n\tvec3 camY   = vec3( 0.0, 1.0, 0.0);\n\tvec3 camZ   = vec3( 0.0, 0.0, 1.0);\n\t\n\tvec3 rO = camPos;\n\tvec3 rD = normalize(uv2.x*camX + uv2.y*camY + camZ);\n\tvec3 finalPos = rO;\n\tvec3 albedo = vec3( 0.0, 0.0, 0.0 );\n\tvec3 normal = vec3( 0.0, 0.0, 0.0 );\n    vec4 scatTrans = vec4( 0.0, 0.0, 0.0, 0.0 );\n    traceScene( fragCoord.x>(iResolution.x/2.0),\n        rO, rD, finalPos, normal, albedo, scatTrans);\n\t\n    \n    //lighting\n    vec3 color = (albedo/3.14) * evaluateLight(finalPos, normal) * volumetricShadow(finalPos, LPOS);\n    // Apply scattering/transmittance\n    color = color * scatTrans.w + scatTrans.xyz;\n    \n    // Gamma correction\n\tcolor = pow(color, vec3(1.0/2.2)); // simple linear to gamma, exposure of 1.0\n   \n#ifndef D_DEMO_FREE\n    // Separation line\n    if(abs(fragCoord.x-(iResolution.x*0.5))<0.6)\n        color.r = 0.5;\n#endif\n    \n\tfragColor = vec4(color ,1.0);\n}\n\n\n\n",
                "name": "Image",
                "description": "",
                "type": "image"
            }
        ]
    }
}