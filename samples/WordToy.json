{
    "Shader": {
        "ver": "0.1",
        "info": {
            "id": "Xst3zX",
            "date": "1451973388",
            "viewed": 5408,
            "name": "Wordtoy",
            "username": "poljere",
            "description": "A simple word processor in Shadertoy! \nThe first pass \"Buffer A\" currently stores the total number of characters introduced as well as each character, the second pass \"Image\" reads texture \"Buffer A\" and renders the letters.",
            "likes": 41,
            "published": 3,
            "flags": 48,
            "tags": [
                "2d",
                "keyboard",
                "word",
                "characters",
                "multipass"
            ],
            "hasliked": 0
        },
        "renderpass": [
            {
                "inputs": [
                    {
                        "id": 258,
                        "src": "/media/previz/buffer01.png",
                        "ctype": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "nearest",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [],
                "code": "// Created by Pol Jeremias - poljere/2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/////////////////////////////////////////////////////////////\n// POST PROCESS\n//\n// This pass adds post processing effects on top of the rest.\n/////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iChannelResolution[0].xy;\n    vec3 col = vec3(0.01, 0.05,0.01) + 0.1*sin(iTime * 2.0 + fragCoord.y * 2.0);\n\n    float amount = 0.002 * length(uv - vec2(0.5,0.5));\n    col.r += texture( iChannel0, vec2(uv.x+amount,uv.y) ).r;\n    col.g += texture( iChannel0, uv ).g;\n    col.b += texture( iChannel0, vec2(uv.x-amount,uv.y) ).b;\n    \n    fragColor = vec4(col, 1.0);\n}",
                "name": "Image",
                "description": "",
                "type": "image"
            },
            {
                "inputs": [
                    {
                        "id": 33,
                        "src": "/presets/tex00.jpg",
                        "ctype": "keyboard",
                        "channel": 1,
                        "sampler": {
                            "filter": "nearest",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    },
                    {
                        "id": 257,
                        "src": "/media/previz/buffer00.png",
                        "ctype": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "nearest",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": 257,
                        "channel": 0
                    }
                ],
                "code": "// Created by Pol Jeremias - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/////////////////////////////////////////////////////////////\n// INPUT AND MEMORY CODE \n//\n// This pass reads the keyboard and stores every key in a \n// texture that later on is use to recreate the text\n/////////////////////////////////////////////////////////////\n\n// Keyboard constants definition\nconst float KEY_BSP   = 8.5/256.0;\nconst float KEY_SP    = 32.5/256.0;\nconst float KEY_LEFT  = 37.5/256.0;\nconst float KEY_UP    = 38.5/256.0;\nconst float KEY_RIGHT = 39.5/256.0;\nconst float KEY_DOWN  = 40.5/256.0;\nconst float KEY_A     = 65.5/256.0;\nconst float KEY_B     = 66.5/256.0;\nconst float KEY_C     = 67.5/256.0;\nconst float KEY_D     = 68.5/256.0;\nconst float KEY_E     = 69.5/256.0;\nconst float KEY_F     = 70.5/256.0;\nconst float KEY_G     = 71.5/256.0;\nconst float KEY_H     = 72.5/256.0;\nconst float KEY_I     = 73.5/256.0;\nconst float KEY_J     = 74.5/256.0;\nconst float KEY_K     = 75.5/256.0;\nconst float KEY_L     = 76.5/256.0;\nconst float KEY_M     = 77.5/256.0;\nconst float KEY_N     = 78.5/256.0;\nconst float KEY_O     = 79.5/256.0;\nconst float KEY_P     = 80.5/256.0;\nconst float KEY_Q     = 81.5/256.0;\nconst float KEY_R     = 82.5/256.0;\nconst float KEY_S     = 83.5/256.0;\nconst float KEY_T     = 84.5/256.0;\nconst float KEY_U     = 85.5/256.0;\nconst float KEY_V     = 86.5/256.0;\nconst float KEY_W     = 87.5/256.0;\nconst float KEY_X     = 88.5/256.0;\nconst float KEY_Y     = 89.5/256.0;\nconst float KEY_Z     = 90.5/256.0;\nconst float KEY_COMMA = 188.5/256.0;\nconst float KEY_PER   = 190.5/256.0;\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\n\n/////////////////////////////////\n// Memory Locations\n/////////////////////////////////\nvec2 fragCoordNumChars = vec2(0.0, 0.0);\n\n\n/////////////////////////////////\n// Memory Management\n/////////////////////////////////\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\nfloat isInside( vec2 p, vec2 c ) \n{ \n    vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); \n}\n\nvoid store( in vec2 fragCoordWrite, in vec4 value, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = (isInside(fragCoord, fragCoordWrite) > 0.0) ? value : fragColor;\n}\n\nfloat isKeyPressed(float key)\n{\n\treturn texture( iChannel1, vec2(key, 0.5) ).x;\n}\n\n/////////////////////////////////\n// Store information\n/////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Read the last mode selected\n    int numChars = int( load(fragCoordNumChars).w );\n    vec4  history= load( fragCoord.xy-0.5 );\n    float chr   = history.x + history.a;\n    \n    // Initialize variables\n    if (iFrame == 0)\n    {\n        history = vec4(0.0);\n        numChars = 0;\n        chr = 0.0;\n    }\n    \n    // Check if the user has changed selection (Thanks Inigo)\n    float ochar = chr;\n    chr = mix( chr, ch_q, step(0.5,isKeyPressed(KEY_Q)) );\n    chr = mix( chr, ch_w, step(0.5,isKeyPressed(KEY_W)) );\n    chr = mix( chr, ch_e, step(0.5,isKeyPressed(KEY_E)) );\n    chr = mix( chr, ch_r, step(0.5,isKeyPressed(KEY_R)) );\n    chr = mix( chr, ch_t, step(0.5,isKeyPressed(KEY_T)) );\n    chr = mix( chr, ch_y, step(0.5,isKeyPressed(KEY_Y)) );\n    chr = mix( chr, ch_u, step(0.5,isKeyPressed(KEY_U)) );\n    chr = mix( chr, ch_i, step(0.5,isKeyPressed(KEY_I)) );\n    chr = mix( chr, ch_o, step(0.5,isKeyPressed(KEY_O)) );\n    chr = mix( chr, ch_p, step(0.5,isKeyPressed(KEY_P)) );\n\n    chr = mix( chr, ch_a, step(0.5,isKeyPressed(KEY_A)) );\n    chr = mix( chr, ch_s, step(0.5,isKeyPressed(KEY_S)) );\n    chr = mix( chr, ch_d, step(0.5,isKeyPressed(KEY_D)) );\n    chr = mix( chr, ch_f, step(0.5,isKeyPressed(KEY_F)) );\n    chr = mix( chr, ch_g, step(0.5,isKeyPressed(KEY_G)) );\n    chr = mix( chr, ch_h, step(0.5,isKeyPressed(KEY_H)) );\n    chr = mix( chr, ch_j, step(0.5,isKeyPressed(KEY_J)) );\n    chr = mix( chr, ch_k, step(0.5,isKeyPressed(KEY_K)) );\n    chr = mix( chr, ch_l, step(0.5,isKeyPressed(KEY_L)) );\n\n    chr = mix( chr, ch_z, step(0.5,isKeyPressed(KEY_Z)) );\n    chr = mix( chr, ch_x, step(0.5,isKeyPressed(KEY_X)) );\n    chr = mix( chr, ch_c, step(0.5,isKeyPressed(KEY_C)) );\n    chr = mix( chr, ch_v, step(0.5,isKeyPressed(KEY_V)) );\n    chr = mix( chr, ch_b, step(0.5,isKeyPressed(KEY_B)) );\n    chr = mix( chr, ch_n, step(0.5,isKeyPressed(KEY_N)) );\n    chr = mix( chr, ch_m, step(0.5,isKeyPressed(KEY_M)) );\n    chr = mix( chr, ch_com, step(0.5,isKeyPressed(KEY_COMMA)) );\n    chr = mix( chr, ch_per, step(0.5,isKeyPressed(KEY_PER)) );\n    \n    chr = mix( chr, ch_sp, step(0.5,isKeyPressed(KEY_SP)) );\n    if( abs(ochar-chr)>0.01 ) numChars++;\n    \n    // Store new data\n    float numCharsf = float(numChars);\n    vec2 fragCoordChar = vec2(  mod(numCharsf, iChannelResolution[0].x), \n                              floor(numCharsf / iChannelResolution[0].x));\n    \n    if(isKeyPressed(KEY_BSP)> 0.0){ chr = 0.0; numCharsf = numCharsf - 1.0; } \n    \n    fragColor = history;          \n    store( fragCoordNumChars, vec4(0.0,0.0,0.0,numCharsf), fragColor, fragCoord );\n    store( fragCoordChar,     vec4(chr,0.0,0.0,0.0),      fragColor, fragCoord );\n}\n",
                "name": "Buf A",
                "description": "",
                "type": "buffer"
            },
            {
                "inputs": [
                    {
                        "id": 257,
                        "src": "/media/previz/buffer00.png",
                        "ctype": "buffer",
                        "channel": 0,
                        "sampler": {
                            "filter": "nearest",
                            "wrap": "clamp",
                            "vflip": "true",
                            "srgb": "false",
                            "internal": "byte"
                        },
                        "published": 1
                    }
                ],
                "outputs": [
                    {
                        "id": 258,
                        "channel": 0
                    }
                ],
                "code": "// Created by Pol Jeremias - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n/////////////////////////////////////////////////////////////\n// UI CODE \n//\n// This pass reads the data stored by the first buffer\n// and writes the characters that are required.\n//\n// SPECIAL THANKS to Flyguy for the font rendering\n//     (https://www.shadertoy.com/view/XtsGRl)\n/////////////////////////////////////////////////////////////\n\n\n/////////////////////////////////\n// Chars rendering\n/////////////////////////////////\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(16, 24)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n â–ˆ     010    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆâ–ˆâ–ˆ -> 111 -> 010 101 101 111 101 101 101 -> 712557\nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \nâ–ˆ â–ˆ    101    \n*/\n\n//Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\n// Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n / pow(2.0,floor(b))),2.0));   \n}\n\n// Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    //Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    //Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n}\n\n// Prints a character.\nfloat chr(float ch, vec2 uv, inout vec2 cursor)\n{\n    float c = sprite(ch, CHAR_SIZE, 0.5 * (uv - cursor));\n    cursor += vec2(CHAR_SPACING.x, 0.0);\n    return c;\n}\n\nvec3 ui(in vec2 fragCoord, inout vec2 cursor)\n{\n\t// Draw UI\n    return vec3(chr(ch_w, fragCoord, cursor) + chr(ch_o, fragCoord, cursor) +\n           chr(ch_r, fragCoord, cursor) + chr(ch_d, fragCoord, cursor) +\n           chr(ch_t, fragCoord, cursor) + chr(ch_o, fragCoord, cursor)+\n           chr(ch_y, fragCoord, cursor) + chr(ch_sp, fragCoord, cursor)+\n           chr(ch_v, fragCoord, cursor) + chr(ch_1, fragCoord, cursor));\n}\n\n\n/////////////////////////////////\n// Memory Management\n/////////////////////////////////\nvec4 load(in vec2 fragCoordRead)\n{\n    return texture(iChannel0, (0.5 + fragCoordRead) / iChannelResolution[0].xy, -100.0 );\n}\n\n\n/////////////////////////////////\n// Utils\n/////////////////////////////////\nfloat hash1( float n ) \n{ \n    return fract(sin(n)*138.5453123); \n}\n\n\n/////////////////////////////////\n// Draw letters!\n/////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    // Read the character from the image buffer\n    vec2 bucket = floor(vec2(fragCoord.x / CHAR_SPACING.x,\n                             ((iResolution.y - fragCoord.y) / CHAR_SPACING.y)));\n    \n    float numCharsRow = floor(iResolution.x / CHAR_SPACING.x);\n    \n    float texelIdBuffA = bucket.y * numCharsRow + bucket.x;\n    \n    vec2  fragCoordBuffA= vec2(  mod(texelIdBuffA, iChannelResolution[0].x),\n    \t\t\t\t\t\t\t floor(texelIdBuffA / iChannelResolution[0].x));\n    \n    vec4 charId = load( fragCoordBuffA );\n    \n    \n    // Draw the chars\n    vec4 c = vec4(0.0); \n    vec2 cursor = floor(vec2(fragCoord.x / CHAR_SPACING.x, fragCoord.y / CHAR_SPACING.y)) * CHAR_SPACING;\n    c += vec4(0.1, 1.0, 0.1, 0.0) * chr(charId.x, fragCoord, cursor);\n    \n    \n    // Draw the selection - Read the number of chars and calculate the last chr\n    float lastChar = 1.0 + load(vec2(0.0)).w;\n    c.xyz += (1.0 - step(0.5, abs(lastChar - texelIdBuffA))) * vec3(0.1, 1.0, 0.1) *\n             (0.5 + 0.5 *sin(iTime * 15.0));\n\n    \n    // Draw the UI\n    cursor = 0.5 * vec2(iResolution.x - STRWIDTH(20.0), STRHEIGHT(1.0));\n    c.xyz += vec3(0.2, 0.1, 0.1) * ui(floor(fragCoord/2.0), cursor);\n    \n    \n    // Draw the background color\n    c.xyz += vec3(0.15,0.15,0.15);\n        \n    //c += vec4(hash1(charId.x));\n    \n    fragColor = c;\n}",
                "name": "Buf B",
                "description": "",
                "type": "buffer"
            }
        ]
    }
}