{"Shader":{"ver":"0.1","info":{"id":"ldd3DX","date":"1542803894","viewed":13270,"name":"Surfer Boy","username":"iq","description":"A surfer boy posing in the beach, in pixar style unapologetically. I had to compromise quality so it would compile in my CPU, and had to model and paint it to camera (rather than full 3D) so I could move fast during the making. I took out the animation.","likes":114,"published":3,"flags":32,"tags":["3d","raymarching","distancefield","sdf"],"hasliked":0},"renderpass":[{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":259,"src":"\/media\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Created by inigo quilez - iq\/2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ A surfer boy in the beach, disney\/pixar style. I had to be very careful\n\/\/ with the complexity, otherwise the browser would crash during shader\n\/\/ compilation I also had to split the boy in two layers because of that,\n\/\/ see below (the single pass version is smaller of course but takes 3 extra\n\/\/ seconds to compile, and renders a bit more slowly)\n\/\/\n\/\/ This is totally painted to camera, it won't work from others perspectives.\n\/\/\n\/\/ I did an animated version (blinking, eyeball micromovements, breathing, \n\/\/ hair and head movement) but it looked super creepy, so I left it out this\n\/\/ time. I need to lear to animate before publishing something like that.\n\/\/\n\/\/ Common   - contains some basic stuff\n\/\/ Buffer A - renders the brackground - not super polished really\n\/\/ Buffer B - blurs the background\n\/\/ Buffer C - paints the boy, except the hand and the board\n\/\/ Image    - paints the hand and the board, and does some minimal postpro\n\n\n\n\/\/ hands and board\nvec3 map( vec3 p )\n{\n    \/\/ hands\n    float d = 1.0;\n\tif( p.x<-0.8 && p.y<-0.1)\n\t{\n\t\tvec3 hp = p - vec3(-0.9,-0.30,0.12);\n\n\t\thp.z *= 1.2;\n\t\t\n\t\tfloat ss = sign(hp.y+0.05);\n\n\t\tvec4 a1 = vec4(-0.030+0.010*ss, -0.050 +0.050 *ss, 0.06, 0.0225);\n\t\tvec4 b1 = vec4(-0.070+0.010*ss, -0.049 +0.051 *ss, 0.05, 0.024);\n\t\tvec4 c1 = vec4(-0.145+0.015*ss, -0.0465+0.0535*ss, 0.01, 0.027);\n\t\tvec4 d1 = vec4(-0.12,           -0.0465+0.0535*ss,-0.06, 0.030);\n\t\tvec3 u1 = vec3(-0.0290+0.011*ss,-0.05  +0.05  *ss, 0.08);\n\t\tvec3 v1 = vec3(-0.0185,         -0.05  +0.05  *ss, 0.08);\n\n\t\tfloat dd =     sdCapsule( hp, a1, b1 ).x;\n\t\tdd = smin( dd, sdCapsule( hp, b1, c1 ).x, 0.005 );\n\t\tdd = smin( dd, sdCapsule( hp, c1, d1 ).x, 0.005 );\n\t\tdd = smax( dd,-sdCapsule( hp, u1, v1, 0.021 ),0.005);\n\t\td = min( d, dd\/1.2 );\n\t\t\n\t\tss = sign(hp.y+0.1);\n\t\t\n\t\tif( hp.y>-0.1 )\n\t\t{\n\t\t\tconst vec4 a2 = vec4(-0.02,-0.050, 0.06, 0.024);\n\t\t\tconst vec4 b2 = vec4(-0.06,-0.050, 0.05, 0.0256);\n\t\t\tconst vec4 c2 = vec4(-0.15,-0.050, 0.01, 0.0288);\n\t\t\tconst vec4 d2 = vec4(-0.13,-0.050,-0.06, 0.032);\n\t\t\tconst vec3 u2 = vec3(-0.018,-0.05,0.08);\n\t\t\tconst vec3 v2 = vec3(-0.017,-0.05,0.08);\n\n\t\t\tdd =           sdCapsule( hp, a2, b2 ).x;\n\t\t\tdd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );\n\t\t\tdd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );\n\t\t\tdd = smax( dd,-sdCapsule( hp, u2, v2, 0.021 ),0.005);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tconst vec4 a2 = vec4(-0.07,-0.145, 0.06, 0.021);\n\t\t\tconst vec4 b2 = vec4(-0.10,-0.145, 0.05, 0.0224);\n\t\t\tconst vec4 c2 = vec4(-0.16,-0.145, 0.01, 0.0252);\n\t\t\tconst vec4 d2 = vec4(-0.15,-0.145,-0.06, 0.028);\n\t\t\tconst vec3 u2 = vec3(-0.07,-0.145,0.08);\n\t\t\tconst vec3 v2 = vec3(-0.05,-0.145,0.08);\n\n\t\t\tdd =           sdCapsule( hp, a2, b2 ).x;\n\t\t\tdd = smin( dd, sdCapsule( hp, b2, c2 ).x, 0.005 );\n\t\t\tdd = smin( dd, sdCapsule( hp, c2, d2 ).x, 0.005 );\n\t\t\tdd = smax( dd,-sdCapsule( hp, u2, v2, 0.019 ),0.005);\n\t\t}\n        d = min( d, dd\/1.2 );\n\t}\n    \n\tvec3 res = vec3(d,1.0,1.0);\n\n    \/\/ nails\n\t{\n\t\tvec3 np = mat3(0.990,0.0,0.141,\n\t\t\t\t\t   0.000,1.0,0.000,\n\t\t\t\t\t   -0.141,0.0,0.990)*\n\t\t\t\t\t   (p-vec3(-0.9,-0.30,0.12));\n\t\td =       sdEllipsoid(np, vec3(-0.025, 0.000,0.056), vec3(0.022,0.018,0.006) );\n\t\td = min(d,sdEllipsoid(np, vec3(-0.025,-0.050,0.056), vec3(0.023,0.019,0.006) ));\n\t\td = min(d,sdEllipsoid(np, vec3(-0.046,-0.100,0.053), vec3(0.022,0.018,0.006) ));\n\t\td = min(d,sdEllipsoid(np, vec3(-0.073,-0.145,0.048), vec3(0.021,0.017,0.006) ));\n\t\tif( d<res.x ) res = vec3(d,9.0,1.0);\n\t}\n\n\t\n    \/\/ board\n\t\/\/if( p.x<-0.2 )\n\t{\n\tvec3 bp = p - vec3(-0.695,-1.5,0.1 );\n\n\tbp.x = 0.15 + almostIdentity( abs(bp.x), 0.05, 0.01 );\n\td = sdEllipsoid( bp, vec3(0.0),vec3(0.65,1.8,0.1) );\n\tif( d<res.x ) res = vec3(d,6.0,1.0);\n\t}\n\t\n\treturn res;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormalmap( in vec3 pos, in float ep )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*map(pos+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*map(pos+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*map(pos+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*map(pos+e.xxx*ep).x );\n#else\n    \/\/ inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n    \n}\n\n\n\/\/=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor, in int sampleID )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i+12*sampleID)));\n\t\t\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );\n        \n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao \/= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = 0.001;\n\tfor( int i=ZERO; i<50; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t ).x;\n\n\t\tres = min( res, smoothstep(0.0,1.0,1.8*k*(h+0.001)\/sqrt(t)) );\n\t\t\n\t\tt += clamp( h, 0.003, 0.1 );\n\t\tif( res<0.001 || t>0.8) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo, in int sampleID )\n{\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = calcNormalmap( pos, 0.0002 );\n\t\n\n\tvec3 mateD = vec3(0.0);\n\tvec2 mateK = vec2(0.0);\n\tfloat mateS = 0.0;\n\tvec3 mateSG = vec3(1.0);\n\n\tif( m<1.5 )\n\t{\n\t\tmateD = vec3(0.132,0.06,0.06);\n\t\t\n\t\tvec3 p = pos;\n\t\tfloat no = texture(iChannel0,p.xy).x;\n\t\tmateSG = vec3(0.75,0.97,1.0);\n\t\tmateK = vec2(0.08,0.5);\n\t\tmateS = 1.0;    \n\t\tmateK *= 0.5 + no;\n\t}\n\telse if( m<6.5 )\n\t{\n        mateD = vec3(0.22,0.24,0.26);\n\t\t\n\t\tvec3 bp = pos - vec3(-0.695,-1.6,0.1 );\n\n\t\tmateD = mix( mateD, vec3(0.15,0.08,0.05), 1.0-smoothstep(0.003,0.01,abs(bp.x)) );\n\t\t\n\t\tfloat h = bp.y - 0.15*sin( 6.0*bp.x );\n\t\th = min( abs(h-1.15)-0.04, abs(h-1.05)-0.01 );\n\t\t\n\t\tmateD = mix( mateD, vec3(0.004), 1.0-smoothstep( 0.01, 0.02, h ) );\n\t\t\n\t\tmateD *= 0.9 + 0.1*texture(iChannel0, 1.0*pos.xy ).x;\n\t\tmateS = 3.0;\n\t\tmateK = vec2(1.0,16.0);\n\t\t\n\t\tvec2 uv = pos.xy*0.1;\n\t\tfloat te = 0.0;\n\t\tfloat s = 0.5;\n\t\tfor( int i=0; i<9; i++ )\n\t\t{\n\t\t\tte += s*texture(iChannel0,uv).x;\n\t\t\tuv *= 2.11;\n\t\t\ts *= 0.6;\n\t\t}\n\t\tmateD = mix( mateD, vec3(0.16,0.08,0.0)*0.27, \t\t\t0.15*smoothstep(0.6,0.9,te) );\n\t\tmateK.x *= 1.0-te;\n\t\t\n\t\t\n\t}\n\telse if( m<9.5 )\n\t{\n\t\tmateD = vec3(0.134,0.07,0.07);\n\t\t\n\t\tvec3 hp = pos - vec3(-0.945,-0.30,0.12);\n\t\t\n\t\tfloat r = length(hp.xy);\n\t\tr = min( r, length(hp.xy-vec2(0.0,-0.05)) );\n\t\tr = min( r, length(hp.xy-vec2(-0.02,-0.095)) );\n\t\tr = min( r, length(hp.xy-vec2(-0.048,-0.14)) );\n\t\t\n\t\tmateD += 0.023*(1.0 - smoothstep( 0.014,0.018,r));\n\t\t\n\t\tmateK = vec2(0.2,2.0);\n\t\tmateS = 1.0;\n\t\t\n\t}\n\t\n\tfloat fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n\tfloat occ = calcAO( pos, nor, sampleID );\n\t\n\tvec3 col = vec3(0.0);\n\t\n    {\n\t\t\/\/ key\n\t\tfloat dif1 = dot(nor,sunDir);\n\t\tvec3 hal = normalize( sunDir-rd );\n\t\tfloat spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\n\t\tfloat sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); \n        \n        sha *= 0.15+0.85*smoothstep(0.1,0.3,length((pos-vec3(-0.45,0.16,0.1))*vec3(1.4,0.4,1.0)));\n        \n\t\tfloat ssha = 1.0;\n\t\tif( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05; }\n\t\tif( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }\n\t\t\n\t\tdif1 = clamp(dif1,0.0,1.0);\n\n\t\tvec3 sha3 = vec3(sha,sha*0.4+0.6*sha*sha,sha*sha);\n\t\t\n\t\tcol += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;\n\t\tcol += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;\n    }\n\t{\n\t\t\/\/ fill\n\t\t\n\t\tcol += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;\n\n\t\tfloat dif1 = 0.5 + 0.5*nor.y;\n\t\tfloat sha = 1.0;\n\t\tfloat spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );\n\t\tcol += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;\n\t}\n\t{\n\t\t\/\/ bounce\n\t\tvec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));\n\t\tfloat dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);\n\t\tcol += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;\n\t}\n\t{\n\t\tcol += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;\n\t\tcol += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;\n\t}\n\n\tcol = pow( col, mateSG );\n\n    return col;        \n}\n\n\/\/--------------------------------------------\n\nvec3 intersect( in vec3 ro, in vec3 rd, float mindist, float maxdist )\n{\n\tvec3 res = vec3(-1.0);\n\t\n\tfloat t = mindist;\n\tfor( int i=ZERO; i<150; i++ )\n\t{\n\t\tvec3 p = ro + t*rd;\n\t\tvec3 h = map( p );\n\t\tres = vec3(t,h.yz);\n\t\tif( abs(h.x)<0.00025 || t>maxdist ) break;\n\t\tt += h.x;\n\t}\n\treturn res;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in int sampleID )\n{\n\tvec4 res = texture(iChannel1,uv);\n\tvec3 col = res.xyz;\n\t\n\tconst float mindist = 0.8;\n\tconst float maxdist = 1.8;\n\t\n\tvec3 tm = intersect( ro, rd, mindist, maxdist );\n\tif( tm.y>-0.5 && tm.x < maxdist )\n\t{\n\t\tcol = shade( ro, rd, tm.x, tm.y, tm.z, sampleID );\n\t}\n\n\tfloat sun = clamp(0.5+0.5*dot( rd, sunDir ),0.0,1.0);\n\tcol += 20.0*vec3(1.2,0.7,0.4)*pow(sun,8.0);\n\n\tcol = pow( col, vec3(0.4545) );\n\n\t\/\/col.z += 0.005;\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\n\tmat3 ca; vec3 ro; float fl;\n\tcomputeCamera( iTime, ca, ro, fl );\n\n#if AA<2\n\tvec2  p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3  rd = normalize( ca*vec3(p,-fl) );\n\tvec3 col = render( ro, rd, fragCoord.xy\/iResolution.xy, 0 );\n#else\n\tvec3 col = vec3(0.0);\n\tfor( int m=ZERO; m<AA; m++ )\n\tfor( int n=ZERO; n<AA; n++ )\n\t{\n\t\tvec2 rr = vec2( float(m), float(n) ) \/ float(AA) - 0.5;\n\t\tvec2 p = (2.0*(fragCoord.xy+rr)-iResolution.xy)\/iResolution.y;\n\t\tvec3 rd = normalize( ca * vec3(p,-fl) );\n\t\tcol += render( ro, rd, (fragCoord+rr)\/iResolution.xy, AA*m+n );\n\t}    \n\tcol \/= float(AA*AA);\n#endif\n\t\t\n\tvec2 q = fragCoord.xy\/iResolution.xy;\n\tcol *= 0.3 + 0.7*pow(16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.1);\n\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat noise( in vec2 p )\n{\n  return -1.0+2.0*textureGood( iChannel0, p-0.5 );\n}\n\nconst float hmin = -6.0;\nconst float hmax = -1.0;\n\nfloat mapWater( in vec3 p )\n{\n    float w = 0.0;\n    float s = 0.5;\n    vec2 q = p.xz;\n    for( int i=0; i<4; i++ )\n    {\n        w += s*noise(q*vec2(0.5,1.0));\n        q = 2.01*(q + vec2(0.03,0.07));\n        s = 0.5*s;\n    }\n    w \/= 0.9375;\n    \n    \n    float h = hmin + (hmax-hmin)*w;\n    \n\n    float cr = 0.0;\n    float wh = 0.2 + 0.8*smoothstep( 0.0, 75.0, -p.z );\n    vec2 pp = p.xz\/50.0;\n    float d = 1e20;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 o = floor( pp );\n        o += vec2( float(i), float(j) );\n        vec4 ra = texelFetch( iChannel0, ivec2(o)&255, 0 );\n        o += ra.xy;\n        vec3 r = p - vec3(o.x*50.0,-4.0-(1.0-wh)*5.0+ra.z*ra.z*2.0-3.0,o.y*50.0 + mod(10.0*iTime*0.2,50.0));\n        r.yz = mat2(0.99,0.141,-0.141,0.99)*r.yz;\n        d = smin( d, sdEllipsoid( r, vec3(0.0,0.0,0.0), (0.2+0.8*wh)*vec3(35.0,(0.1+0.9*ra.z*ra.z)*3.0,15.0)), 2.10 );\n        \n        float pm = (0.1+0.9*wh)*15.0;\n        float cc = 1.0-smoothstep( 0.0, 2.0, abs(abs(r.z)-pm) );\n        cr = max( cr, cc );\n    }\n    d = d - w*0.5;\n    d = smin( d, p.y+4.0, 1.0);\n    d = d - w*0.03;\n\n    return d;\n}\n\nconst vec3 bnor = normalize(vec3(0.0,0.9,-0.05));\n\nfloat mapBeach( in vec3 p )\n{\n    float d = dot(p,bnor)-2.8;\n    \n    vec2 w = vec2(0.0);\n    vec2 s = vec2(0.5);\n    vec2 t = vec2(0.0);\n\t\n    vec2 q = p.xz*1.25;\n    q += 1.0*cos( 0.3*q.yx );\n    for( int i=0; i<7;i++ )\n    {\n        float n = 0.5 + 0.5*noise(q);\n\t\tw += s*vec2(1.0-almostIdentity(abs(-1.0+2.0*n),0.1,0.05 ),n);\n\t\tt += s;\n        q = mat2(1.6,1.2,-1.2,1.6)*q;\n\t\ts *= vec2(0.3,0.5);\n    }\n\tw \/= t;\n\n\tfloat f = w.x + w.y*0.4;\n    \n    float wet = 1.0-smoothstep(-16.0, -10.0, p.z );\n    \n    return d - 0.15*mix(f, (1.0-f)*0.1, wet );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormalmapWater( in vec3 pos, in float ep )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*mapWater(pos+e.xyy*ep) + \n\t\t\t\t\t e.yyx*mapWater(pos+e.yyx*ep) + \n\t\t\t\t\t e.yxy*mapWater(pos+e.yxy*ep) + \n\t\t\t\t\t e.xxx*mapWater(pos+e.xxx*ep) );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormalmapBeach( in vec3 pos, in float ep )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*mapBeach(pos+e.xyy*ep) + \n\t\t\t\t\t e.yyx*mapBeach(pos+e.yyx*ep) + \n\t\t\t\t\t e.yxy*mapBeach(pos+e.yxy*ep) + \n\t\t\t\t\t e.xxx*mapBeach(pos+e.xxx*ep) );\n}\n\n\nfloat intersectWater( in vec3 ro, in vec3 rd, in float mint )\n{\n    float t = mint;\n    for( int i=0; i<200; i++ )\n    {\n        vec3 p = ro + t*rd;\n        float h = mapWater( p );\n        if( abs(h)<(0.0004*t) ) break;\n        t += h;\n    }\n\treturn t;\n}\n\nvec3 sky( in vec3 rd )\n{\n    if( rd.y<0.0 ) return vec3(0.0,0.05,0.10);\n    \n    \/\/ gradient\n    float dy = max(0.0,rd.y);\n    vec3 col = vec3(0.3,0.7,0.9) - dy*0.5;\n\tcol = mix( col, vec3(1.3,0.45,0.10), exp(-4.0*dy) );\n\tcol = mix( col, vec3(1.5,0.10,0.05), exp(-30.0*dy) );\n\tcol = mix( col, vec3(0.1,0.10,0.10), exp(-60.0*dy) );\n    \n    \/\/ clouds\n    vec2 uv = 0.003*rd.xz\/rd.y;\n\tuv += 0.006*sin(100.0*uv.yx);\n    float f  = 0.5000*texture( iChannel0, 1.0*uv.xy ).x;\n          f += 0.2500*texture( iChannel0, 1.9*uv.yx ).x;\n          f += 0.1250*texture( iChannel0, 4.1*uv.xy ).x;\n          f += 0.0625*texture( iChannel0, 7.9*uv.yx ).x;\n          \n    return mix( col, vec3(1.0,0.37,0.4)*(1.0-f)*0.5,0.3*smoothstep(0.4,0.7,f) );\n}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n\tvec3 col = vec3(0.0);\n    \n    float ma = -1.0;\n    float tmin = 1e20;\n    \n    float t = (hmax-ro.y)\/rd.y;\n    if( t>5.0 )\n    {\n        t = intersectWater( ro, rd, t );\n        ma = 0.0;\n        tmin = t;\n    }\n\n    t = (-2.8-dot(ro,bnor))\/dot(rd,bnor);\n    if( t>0.0 && t<tmin)\n    {\n\t\ttmin = t;\n\t\tma = 1.0;\n    }\n\n    if( ma<0.0 )\n    {\n        col = sky( rd );\n    }\n    else if( ma<0.5 )\n    {\n    \tvec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormalmapWater(pos,0.0001*tmin);\n\n        float h = (pos.y - hmin)\/(hmax-hmin);\n        float f = exp(-0.01*tmin);\n        col = mix( vec3(0.03,0.1,0.1), vec3(0.02,0.04,0.08), 1.0-f );\n        \n        h = 1.0-abs(nor.y);\n        col += h*vec3(0.00,0.03,0.03)*2.0;\n\n        vec3 ref = reflect( rd, nor );\n        float kr = pow( clamp(1.0 + dot( rd, nor ),0.0,1.0), 5.0 );\n        col += 0.7*(0.01 + 0.99*kr)*sky( ref );\n        \n        \n        float dif = clamp( dot(nor,sunDir),0.0,1.0);\n        col *= 0.8 + 0.4*dif;\n        col *= 0.75;\n        \n        \/\/ foam waves\n        float foam = smoothstep( -0.5, 0.1, -nor.y );\n\t\t\/\/ foam shore\n\t\tfloat te = texture(iChannel0,0.016*pos.xz + vec2(-0.002,-.007)*iTime).x;\n\t\tfoam += \n\t\tsmoothstep(-24.0,-23.0,pos.z + 0.5*sin(pos.x*0.4+te*2.0))*\n\t\tsmoothstep(0.4,0.5,te)*0.8;\n\t    col = mix( col, vec3(0.8,0.9,1.0), 0.4*foam );\n    \n        \/\/ fog\n\t\tcol = mix( col, vec3(0.1), 1.0-exp(-0.000001*tmin*tmin) );\n    }\n\telse if( ma<1.5 )\n    {\n        col = vec3(0.0);\n\n        vec3 pos = ro + tmin*rd;\n        vec3 nor = calcNormalmapBeach(pos,0.0002);\n\n\t\tvec3 mateD = vec3(1.0,0.7,0.5)*0.17;\n        vec2 mateK = vec2(1.0,0.5);\n        float mateS = 0.0;\n\n\t\t\n        float fr = pow(clamp( 1.0+dot(rd,nor), 0.0, 1.0 ),2.0);\n\t\tmateD += 0.05*vec3(1.0,0.5,0.2)*fr;\n\n\t\t\n        float wet = 1.0-smoothstep(-17.0, -11.0, pos.z );\n\t\tmateD = mix( mateD, vec3(0.05,0.02,0.0)*0.8, wet );\n        mateK.x += 12.0*wet;\n        mateK.y += 9.0*wet;\n        \n\t\tmateD *= 0.9;\n        \n\t\tfloat dif1 = clamp( -0.1+1.4*dot(nor,sunDir),0.0,1.0);\n        vec3 hal = normalize( sunDir-rd );\n        float spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\t\tcol += mateD*4.0*vec3(2.5,1.0,0.5)*dif1;\n\t\t\tcol += mateK.x*vec3(1.4,1.30,1.3)*dif1*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0));\n\n        col += mateD*vec3(1.0,0.9,0.9)*(0.5+0.5*nor.y)*0.2;\n        col += mateK.x*vec3(0.8,0.8,0.9)*smoothstep( -0.1,0.3,reflect(rd,nor).y) *(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0));\n        \n    }\n    \n    return vec4(col,tmin);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    mat3 ca; vec3 ro; float fl;\n    computeCamera( iTime, ca, ro, fl );\n    \n    vec2  p = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n    vec3  rd = normalize( ca * vec3(p,-fl) );\n    \n    fragColor = render( ro, rd );\n}","name":"Buffer A","description":"","type":"buffer"},{"inputs":[],"outputs":[],"code":"\/\/ Created by inigo quilez - iq\/2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/ antialiasing - make AA 2, meaning 4x AA, if you have a fast machine\n#define AA 1\n\nconst vec3 sunDir = normalize( vec3(1.0,0.5,0.7) );\n\n\nvoid computeCamera( in float time, out mat3 rCam, out vec3 rRo, out float rFl )\n{\n    vec3 ro = vec3(-0.045+0.05*sin(0.12*time),-0.04,1.3);\n\tvec3 ta = vec3(-0.19,-0.08,0.0);\n\tfloat fl = 2.45;\n    \n    vec3 w = normalize(ta-ro);\n\tfloat k = inversesqrt(1.0-w.y*w.y);\n    rCam = mat3( vec3(-w.z,0.0,w.x)*k, \n                 vec3(-w.x*w.y,1.0-w.y*w.y,-w.y*w.z)*k,\n                 -w);\n    rRo = ro;\n    rFl = fl;\n}\n\n\/\/------------------------------------------------------\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/texture\/texture.htm\nfloat textureGood( sampler2D sam, in vec2 x )\n{\n\tivec2 p = ivec2(floor(x));\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = texelFetch(sam,(p+ivec2(0,0))&255,0).x;\n\tfloat b = texelFetch(sam,(p+ivec2(1,0))&255,0).x;\n\tfloat c = texelFetch(sam,(p+ivec2(0,1))&255,0).x;\n\tfloat d = texelFetch(sam,(p+ivec2(1,1))&255,0).x;\n\treturn mix(mix( a, b,f.x), mix( c, d,f.x), f.y);\n}\n\n\/\/------------------------------------------------------\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/functions\/functions.htm\nfloat almostIdentity( float x, float m, float n )\n{\n    if( x>m ) return x;\n    float a = 2.0*n - m;\n    float b = 2.0*m - 3.0*n;\n    float t = x\/m;\n    return (a*t + b)*t*t + n;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25\/k;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/smin\/smin.htm\nfloat smax( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( a, b, h ) + k*h*(1.0-h);\n}\n\n\/\/------------------------------------------------------\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdEllipsoid( in vec3 p, in vec3 c, in vec3 r )\n{\n  p = p-c;\n  float k0 = length(p\/r);\n  float k1 = length(p\/(r*r));\n  return k0*(k0-1.0)\/k1;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCapsule( in vec3 p, in vec3 a, in vec3 b, in float r )\n{\n  vec3 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)\/dot(ba,ba),0.0,1.0);\n  return length(pa-ba*h) - r;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec2 sdCapsule( in vec3 p, in vec4 a, in vec4 b )\n{\n  vec3 pa = p-a.xyz, ba = b.xyz-a.xyz;\n  float h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n  return vec2( length(pa-ba*h) - mix(a.w,b.w,h), h );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdSphere( in vec3 p, in vec3 c, in float r )\n{\n  return length(p-c)-r;\n}\n\nfloat sdEllipsoidXY2Z( in vec3 p, in vec3 r )\n{\n  vec3 d = p\/r;\n  float h = pow(d.x*d.x + abs(d.y*d.y*d.y) + d.z*d.z, 1.0\/3.0); \n  return (h-1.0)*min(r.x,min(r.y,r.z));\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat sdCone( in vec3 p, in vec2 c )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n\n  vec2 a = q - c*clamp( (q.x*c.x+q.y*c.y)\/dot(c,c), 0.0, 1.0 );\n  vec2 b = q - c*vec2( clamp( q.x\/c.x, 0.0, 1.0 ), 1.0 );\n  \n  float s = -sign( c.y );\n  vec2 d = min( vec2( dot( a, a ), s*(q.x*c.y-q.y*c.x) ),\n\t\t\t    vec2( dot( b, b ), s*(q.y-c.y)  ));\n  return -sqrt(d.x)*sign(d.y);\n}\n\n\/\/ http:\/\/research.microsoft.com\/en-us\/um\/people\/hoppe\/ravg.pdf\nfloat det( vec2 a, vec2 b ) { return a.x*b.y-b.x*a.y; }\nvec3 getClosest( vec2 b0, vec2 b1, vec2 b2 ) \n{\n  float a =     det(b0,b2);\n  float b = 2.0*det(b1,b0);\n  float d = 2.0*det(b2,b1);\n  float f = b*d - a*a;\n  vec2 d21 = b2-b1;\n  vec2 d10 = b1-b0;\n  vec2 d20 = b2-b0;\n  vec2 gf = 2.0*(b*d21+d*d10+a*d20); gf = vec2(gf.y,-gf.x);\n  vec2 pp = -f*gf\/dot(gf,gf);\n  vec2 d0p = b0-pp;\n  float ap = det(d0p,d20);\n  float bp = 2.0*det(d10,d0p);\n  float t = clamp( (ap+bp)\/(2.0*a+b+d), 0.0 ,1.0 );\n  return vec3( mix(mix(b0,b1,t), mix(b1,b2,t),t), t );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nvec4 sdBezier2( vec3 a, vec3 b, vec3 c, vec3 p, out vec3 resP )\n{\n  vec3 w = normalize( cross( c-b, a-b ) );\n  vec3 u = normalize( c-b );\n  vec3 v =          ( cross( w, u ) );\n\n  vec2 m = vec2( dot(a-b,u), dot(a-b,v) );\n  vec2 n = vec2( dot(c-b,u), dot(c-b,v) );\n  vec3 q = vec3( dot(p-b,u), dot(p-b,v), dot(p-b,w) );\n\n  vec3 cp = getClosest( m-q.xy, -q.xy, n-q.xy );\n\n  resP = mix( mix(a,b,cp.z), mix(b,c,cp.z), cp.z );\n\n  return vec4( sqrt(dot(cp.xy,cp.xy)+q.z*q.z), cp.z, length(cp.xy), q.z );\n}\n\nvec4 sdBezier( vec3 a, vec3 b, vec3 c, vec3 p )\n{\n  vec3 kk;\n  return sdBezier2(a,b,c,p,kk);\n}\n\n\/\/ trick by klems\n#define ZERO (min(iFrame,0))\n","name":"Common","description":"","type":"common"},{"inputs":[{"id":257,"src":"\/media\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 q = fragCoord\/iResolution.xy;\n\n    vec4 acc = vec4(0.0);\n    const int N = 5;\n\tfor( int j=-N; j<=N; j++ )\n    for( int i=-N; i<=N; i++ )\n    {\n        vec2 off = vec2(float(i),float(j));\n        \n        vec4 tmp = texture( iChannel0, q + off\/vec2(1280.0,720.0) ); \n        if( dot(off,off) < float(N*N) )\n        {\n            acc += vec4(tmp.xyz,1.0);\n        }\n    }\n    vec3 col = acc.xyz \/ acc.w;\n\n    fragColor = vec4(col,1.0);\n}\n","name":"Buffer B","description":"","type":"buffer"},{"inputs":[{"id":30,"src":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"},"published":1},{"id":258,"src":"\/media\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2018\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 corner1 = vec3(-0.088,-0.103,0.084);\nconst vec3 center  = vec3(-0.005,-0.193,0.14);\nconst vec3 corner2 = vec3( 0.098,-0.105,0.08);\n\nvec3 transformHead( in vec3 p )\n{\n  p.x += 0.012;\n  return mat3( 0.986264,-0.097838, -0.133010,\n               0.086792, 0.992467, -0.086465,\n               0.140468, 0.073733,  0.987326)*p;\n}\n\nvec3 transformHat(in vec3 p)\n{\n  p.y -= 0.03;\n  p = mat3( 0.79200, -0.141, 0.59400,\n           -0.26976,  0.792, 0.54768,\n           -0.54768, -0.594, 0.58924)*p;\n  p.y -= 0.1;\n  return p;\n}\n\nvec3 map( vec3 p )\n{\n\tvec3 headp = transformHead( p );\n\tvec3 headq = vec3( abs(headp.x), headp.yz );\n\n    \/\/ head\n\tfloat d = sdEllipsoid( headp, vec3(0.0,0.015,-0.06 ),vec3(0.33,0.365,0.34) );\n\td = smax(d,-sdEllipsoid( vec3( almostIdentity( headq.x, 0.03, 0.01 ), headp.yz),  vec3( 0.25,0.06,0.4),vec3(0.4,0.2,0.2) ), 0.015);\n\td = smin(d,sdEllipsoid( headp, vec3(0.0,-0.165,0.13),vec3(0.22,0.15,0.145)), 0.01 );\n\td = smin(d,sdEllipsoid( headp, vec3(0.01,-0.2,0.17),vec3(0.12,0.115,0.105)), 0.01 );\n\td = smin(d,sdEllipsoid( headq, vec3(0.1,-0.103,0.09),vec3(0.175,0.146,0.18) ), 0.02);\n\n    \n    \/\/ nose\n\tvec3 n = headp-vec3(0.0,0.1,0.23);\n\tn.x -= n.y*n.y*0.18;\n\tn.yz = mat2(0.98,0.198997,-0.198997,0.98)*n.yz;\n\td = smin( d, sdCone( n, vec2(0.01733,-0.13) ), 0.03);\n\tn.yz -= vec2(-0.102975, 0.004600);\n\tvec3 m = vec3(abs(n.x),n.yz);\n\tfloat na = sdCone( n, vec2(0.527,-0.85) );\n\tna = smax( na, sdSphere(n,vec3(0.0,-0.03,-0.04),0.1), 0.015 );\n\tna = smin( na, sdEllipsoid(m, vec3(0.038,-0.085,0.0),vec3(0.027)), 0.016 );\n\tna = smin( na, sdEllipsoid(m, vec3(0.0,-0.11,-0.01), vec3(0.02,0.02,0.02)), 0.02 );\n\tna = smax(na,-sdEllipsoid(m, vec3(0.033,-0.09,0.008),vec3(0.01,0.02,0.009)*1.5), 0.008 );\n\td = smin( d, na, 0.01);\n\n    \/\/ mouth\n\tvec3 bocap = headp-vec3(-0.006,-0.026,0.22);\n\tvec3 bocap3 = bocap;\n\tbocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;\n\tvec3 bocap2 = bocap;\n\tbocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;\n\tfloat  labioa = sdCone(bocap, vec2(0.219,-0.18) );\n\tlabioa = smax( labioa, sdEllipsoid(bocap,vec3(0.0,0.1,-0.15), vec3(0.22,0.35,0.34)), 0.02 );\n\td = smin( d, labioa, 0.015 );\n\td = smax( d, -sdCapsule( bocap, vec3(0.0,-0.077,0.115),vec3(0.0,-0.09,0.135), 0.013 ), 0.01 );\n\tbocap2.y -= min(bocap2.x*bocap2.x*4.0,0.04);\n\td = smax( d, -sdEllipsoid(bocap2,vec3(0.0,-0.172,0.15), vec3(0.09+0.008*sign(bocap.x),0.017,0.25)), 0.01 );\t\t\n\tvec4 b = sdBezier( corner1, center, corner2, bocap );\n\td = smin(d,b.x - 0.0075*sqrt(4.0*b.y*(1.0-b.y)), 0.005);\n\n    \/\/ ears\n\tvec3 earq = headq - vec3(0.34,-0.04,0.02);\n\tearq.xy = mat2(0.9,0.436,-0.436,0.9)*earq.xy;\n\tearq.xz = mat2(0.8,0.6,-0.6,0.8)*earq.xz;\n\tfloat ear = sdEllipsoid( earq, vec3(0.0),vec3(0.08,0.12,0.09) );\n\tear = smax( ear, (abs(earq.z)-0.016), 0.01 );\n\tear = smin( ear, sdSphere(earq,vec3(0.015,0.0,-0.03),0.04), 0.02);        \n\tear = smax( ear, -0.8*sdEllipsoid( earq, vec3(0.0,0.022,0.02),vec3(0.06,0.08,0.027) ),0.01 );\n\tear = smax( ear, -sdEllipsoid( earq, vec3(-0.01,-0.01,0.01),vec3(0.04,0.04,0.05) ), 0.01 );\n\td = smin(d,ear, 0.015);\n    \n    \/\/ eye sockets\n\td = smax(d,-sdEllipsoid( headq, vec3(0.1,0.03,0.11),vec3(0.105,max(0.0,0.12-0.2*headq.x),0.115)+0.01),0.01 );\n\tb = sdBezier( vec3(0.053,0.017,0.225), vec3(0.12,-0.02,0.255), vec3(0.18,0.02,0.205), headq-vec3(0.0,0.03-0.04,0.0) );\n\td = smin(d,b.x - 0.003*b.y*(1.0-b.y)*4.0,0.012);\n\n    \/\/ cheen fold\n\tn = (headp-vec3(0.14,-0.16,0.297));\n\tn.xy = mat2(0.8,0.6,-0.6,0.8)*n.xy;\n\td = smax(d, -sdEllipsoid( n,  vec3(0.0), vec3(0.096,0.01,0.03)), 0.007);\n\t\n    \/\/ neck\/body\n\t{\n\tvec3 q = vec3( abs(p.x), p.yz );\n\td = smin( d, sdCapsule( p, vec4(0.0,-0.1,-0.1,0.1), vec4(0.0,-0.6,-0.1, 0.12 )).x, 0.05 );\n\td = smin( d, sdCapsule( q, vec3(0.0,-0.62,-0.08), vec3(0.24,-0.71,0.02-0.1), 0.16 ), 0.05 );        \n\td = smin( d, sdCapsule( q, vec4(0.046,-0.555,0.05,0.01), vec4(0.250,-0.55,-0.035,-0.02) ).x, 0.03 );\n\t}\n    \n\tvec3 res = vec3(d,1.0,1.0);\n    \n\n    \/\/ eyes\n\tm = headq - vec3(0.0021,0.0,0.019);\n\td = sdEllipsoid( m, vec3(0.1,0.03,0.11),vec3(0.105,0.09,0.1) );\n\td = smax(d,-sdEllipsoid( headq, vec3(0.102+0.004*sign(headp.x)*1.8,0.03+0.004*1.8,0.28),vec3(0.07) ),0.001);\n\tif( d<res.x ) res = vec3(d,2.0,1.0);\n\n    \/\/ teeth\n\t{\n\tbocap3 = bocap3 - vec3(0.01,-0.055,0.04);\n\tbocap3.xz = mat2x2(0.99,0.141,-0.141,0.99)*bocap3.xz;\n\td = sdCappedCylinder( bocap3.xzy, vec2(0.11,0.01) );\n\tvec3 dd = bocap3;\n\tdd.x = mod(dd.x+0.0075,0.015)-0.0075;\n\tfloat sp = sdBox( dd-vec3(0.0,-0.1,0.0), vec3(0.0004,0.018,0.015) );\n\td = smax(d,-sp,0.003);\n\td = max( d, dot(bocap3.xy,vec2(-0.707,0.707))+0.05 );\n\tif( d<res.x ) res = vec3(d,8.0,1.0);\n\t}\n\n\t\n\t\/\/ eyebrows\n\tb = sdBezier( vec3(0.035,0.16,0.0), vec3(0.1,0.18,-0.02), vec3(0.2,0.12,-0.1), \n\t(headq-vec3(0.0,0.0,0.25))*vec3(1.0,1.0,2.0) );\n\td = b.x - 0.01*sqrt(clamp(1.0-b.y,0.0,0.9));\n\tfloat fr = (sign(b.w)*headq.x*0.436+0.9*headq.y);\n\tfloat cp = cos(1300.0*fr);\n\tcp -= 0.5*cos(600.0*fr); \n\tcp += 0.3*cos(330.0*fr);\n\tcp *= clamp(1.0-3.0*headq.x,0.0,0.8);\n\td -= cp*0.0017;\n\td\/=1.5;\n\tif( d<res.x ) { res = vec3(d,3.0,0.4);}\n\n    \/\/ hair\n\t\/\/if( p.x>-0.4 && p.y>-0.1) \/\/ +10%\n\t{\n\t\tfloat hh = 0.27 - headp.y;\n\n\t\tfloat ss = sign(headp.x);\n\n\t\tvec3 pelop = headp;\n\t\tpelop.x += (1.0-hh)*0.007*cos(pelop.y*30.0);\n\t\tvec3 peloq = vec3( abs(pelop.x), pelop.yz );\n\t\t\n\t\tvec3 ta = vec3(0.0);\n\t\tfloat vc = 0.0;\n\n\t\t{\n\t\tconst vec3 p0a = vec3(0.05,0.3,0.15);\n\t\tconst vec3 p0b = vec3(0.18,0.17,0.22);\n\t\tconst vec3 p0c = vec3(0.1,0.2,0.23);\n\t\tvec4 b = sdBezier( p0a, p0c, p0b, pelop );\n\t\tfloat d1 = b.x - 0.06*(1.0-0.9*b.y);\n\t\td = d1; ta = p0b - p0a; vc = b.y;\n\t\t}\n\t\t{\n\t\tconst vec4 p1a = vec4(-0.04,0.26,0.15,0.075);\n\t\tconst vec4 p1c = vec4(0.02,0.2,0.24,0.015);\n\t\tvec2 b = sdCapsule(pelop, p1a, p1c );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = (p1a.xyz-p1c.xyz)*vec3(ss,1.0,1.0); vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec4 p2a = vec4(0.16,0.25,0.14,0.07);\n\t\tvec4 p2b = vec4(0.185+0.025*ss,0.14,0.23-0.02*ss,0.006);\n\t\tvec2 b = sdCapsule(peloq, p2a, p2b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p2b.xyz-p2a.xyz; vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec3 p3a = vec3(0.205,0.20,0.14);\n\t\tvec3 p3b = vec3(0.255+0.01*ss,0.05,0.17);\n\t\tvec3 p3c = vec3(0.21+0.01*ss,0.15,0.18);\n\t\tvec4 b = sdBezier( p3a, p3c, p3b, peloq );\n\t\tfloat d1 = b.x - 0.06*(1.0-0.9*b.y);\n\t\tif( d1<d ) { d=d1; ta = p3b-p3a; vc = b.y;}\n\t\t}\n\t\t{\n\t\tconst vec4 p4a = vec4(0.24,0.16,0.11,0.06);\n\t\tvec4 p4b = vec4(0.285,-0.04,0.14,0.006);\n\t\tvec2 b = sdCapsule(peloq, p4a, p4b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p4b.xyz-p4a.xyz; vc = b.y; }\n\t\t}\n\t\t{\n\t\tconst vec4 p5a = vec4(0.275,0.12,0.07,0.06);\n\t\tvec4 p5b = vec4(0.295,-0.09,0.1,0.006);\n\t\tvec2 b = sdCapsule(peloq, p5a, p5b );\n\t\tfloat d1 = b.x;\n\t\tif( d1<d ) { d=d1; ta = p5b.xyz-p5a.xyz; vc = b.y; }\n\t\t}\n\n\t\t\n\t\t{\n\t\tvec3 vv = normalize(vec3(ta.z*ta.z+ta.y*ta.y, -ta.x*ta.y, -ta.x*ta.z) );\n\t\tfloat ps  = dot(peloq,vv);\n\t\td -= 0.003*sin(300.0*ps);\n\t\td -= 0.008*(-1.0+2.0*textureGood( iChannel0, vec2(1024.0*ps,vc*5.12) ));\n\t\t}\n\t\t\n\t\tif( d<res.x ) res = vec3(d,3.0,vc);\n\t}\n\n    \/\/ eyelashes\n\t{\n\tvec3 cp;\n\tvec4 b = sdBezier2(  vec3(0.0525+0.0025*sign(headp.x),0.063, 0.225), \n\t\t\tvec3(0.120,0.135, 0.215), vec3(0.1825+0.0025*sign(headp.x),0.050, 0.200), \n\t\t\theadq, cp );\n\tfloat ls = 4.0*b.y*sqrt(1.0-b.y);\n\td = b.x - 0.002*ls;\n\td += 0.001*ls*sin(headq.x*300.0-headq.y*300.0)*step(cp.y,headq.y);\n\td += 0.001*ls*sin(headq.x*1000.0-headq.y*1000.0)*step(cp.y,headq.y);\n\tif( d<res.x ) { res = vec3(d,3.0,0.35);}\n    }\n\t\n\n    \/\/ hat\n    {\n\tvec3 hatp = transformHat( headp );\n\td = sdEllipsoidXY2Z( hatp, vec3(0.36,0.38,0.365) );\n\td = abs(d+0.003)-0.003;\n\td = smax(d,-0.065-hatp.y,0.006);\n\tfloat gb = abs(hatp.x)-hatp.z-0.0975;\n\td -= 0.002*sqrt(clamp(abs(gb)\/0.015,0.0,1.0)) - 0.002;\n\thatp.y += 0.1;\n\tfloat p1 = abs(sin(600.0*hatp.x+hatp.y*200.0));\n\tfloat p2 = abs(cos(150.0*hatp.z)*sin(150.0*hatp.y));\n\tp2 *= smoothstep(0.01,0.02,hatp.y-0.035);\n\td -= 0.0005*mix(p1,2.0*p2,smoothstep(0.0,0.01,gb));\n\tif( d<res.x ) res = vec3(d,4.0,1.0);\n\tvec3 vp = hatp - vec3(0.0,0.19,0.0);\n\tvp.yz = mat2(0.8,-0.6,0.6,0.8)*vp.yz;\n\tvp.y -= 0.2*sqrt(clamp(1.0-vp.x*vp.x\/0.115,0.0,1.0))-0.1;\n\td = 0.8*sdEllipsoid( vp, vec3(0.0,0.0,0.25),vec3(0.3,0.04,0.35) );\n\tif( d<res.x ) res = vec3(d,5.0,1.0);\n    }\t\n\t\n\t\n\treturn res;\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/normalsSDF\/normalsSDF.htm\nvec3 calcNormalmap( in vec3 pos, in float ep )\n{\n#if 0    \n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize(e.xyy*map(pos+e.xyy*ep).x + \n\t\t\t\t\t e.yyx*map(pos+e.yyx*ep).x + \n\t\t\t\t\t e.yxy*map(pos+e.yxy*ep).x + \n\t\t\t\t\t e.xxx*map(pos+e.xxx*ep).x );\n#else\n    \/\/ inspired by klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+e*ep).x;\n    }\n    return normalize(n);\n#endif    \n}\n\n\/\/=========================================================================\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat ao = 0.0;\n\n\tvec3 v = normalize(vec3(0.7,0.5,0.2));\n\tfor( int i=ZERO; i<12; i++ )\n\t{\n\t\tfloat h = abs(sin(float(i)));\n\t\tvec3 kv = v + 2.0*nor*max(0.0,-dot(nor,v));\n\t\tao += clamp( map(pos+nor*0.01+kv*h*0.08).x*3.0, 0.0, 1.0 );\n\t\tv = v.yzx; if( (i&2)==2) v.yz *= -1.0;\n\t}\n\tao \/= 12.0;\n\tao = ao + 2.0*ao*ao;\n\treturn clamp( ao*5.0, 0.0, 1.0 );\n}\n\n\/\/ http:\/\/iquilezles.org\/www\/articles\/rmshadows\/rmshadows.htm\nfloat calcSoftShadow( in vec3 ro, in vec3 rd, float k )\n{\n\tfloat res = 1.0;\n\tfloat t = 0.001;\n\tfor( int i=ZERO; i<50; i++ )\n\t{\n\t\tfloat h = map(ro + rd*t ).x;\n\t\tres = min( res, smoothstep(0.0,1.0,1.4*k*(h+0.0015)\/sqrt(t)) );\n\t\tt += clamp( h, 0.003, 0.1 );\n\t\tif( res<0.001 || t>0.8) break;\n\t}\n\treturn clamp(res,0.0,1.0);\n}\n\n\nvec3 shade( in vec3 ro, in vec3 rd, in float t, in float m, in float matInfo )\n{\n\tfloat eps = (abs(m-3.0)<0.2) ? 0.002: 0.0002;\n\t\n\tvec3 pos = ro + t*rd;\n\tvec3 nor = calcNormalmap( pos, eps );\n\t\n\n\tvec3 mateD = vec3(0.0);\n\tvec2 mateK = vec2(0.0);\n\tfloat mateS = 0.0;\n\tvec3 mateSG = vec3(1.0);\n\n\tif( m<1.5 )\n\t{\n\t\tmateD = vec3(0.132,0.06,0.06);\n\t\t\n\t\tvec3 p = transformHead( pos );\n\t\tvec3 headp = p;\n\t\tvec3 q = vec3( abs(p.x), p.yz );\n\n\t\tfloat m = 1.0 - smoothstep( 0.04, 0.14, length(q-vec3(0.16,-0.11,0.23)) );\n\t\tfloat no = texture(iChannel0,p.xy).x;\n\t\tm = clamp( m + 0.25*(-1.0+2.0*no), 0.0, 1.0 );\n\t\tmateD = mix( mateD, vec3(0.13,0.03,0.03), m );\n\t\t\n\n\t\tmateSG = vec3(0.75,0.97,1.0);\n\n\t\t\t\t\t\n\t\tm = 1.0 - smoothstep( 0.04, 0.17, length(q-vec3(0.45,-0.01,0.0)) );\n\t\tmateD += vec3(1.0,0.01,0.0)*m*0.3*(1.0+0.4*sign(p.x));\n\t\tmateSG = mix( mateSG, vec3(0.3-0.1*sign(p.x),0.9,1.0), m );;\n\n\t\tm = 1.0 - smoothstep( 0.05, 0.1, length(vec3(0.5,1.0,1.0)*(q-vec3(0.0,-0.06,0.23))) );\n\n\t\tvec2 uv = pos.xy*22.0;\n\t\tvec2 iuv = floor(uv);\n\t\tvec2 fuv = fract(uv);\n\t\tvec4 ran = texelFetch( iChannel0, (ivec2(iuv)+6)&255, 0 );\n\t\tvec2 off = ran.xy;\n\t\tfloat sss = pow(ran.z,5.0);\n\t\tfloat size = max(0.0,(0.5+0.5*m)*(0.3+0.7*sss)*0.12);\n\t\tfloat fr = 1.0 - smoothstep( size*0.5, size*2.0, length(fuv-off) );\n\t\tmateD = mix(mateD,vec3(0.25,0.05,0.0)*0.2, 0.6*(1.0-0.4*sss)*fr );\n\t\t\t\t\t\n\t\tmateK = vec2(0.08,0.5);\n\t\tmateS = 1.0;    \n\n\t\t\n\t\tvec3 bocap = headp-vec3(-0.006,-0.025,0.22);\n\t\tbocap.xy = mat2x2(0.99,-0.141,0.141,0.99)*bocap.xy;\n\t\tbocap.yz = mat2x2(0.9,-0.346,0.346,0.9)*bocap.yz;\n\t\t\n\t\t{\n\t\tvec4 b = sdBezier( corner1, center, corner2, bocap );\n\t\tfloat d1 = b.x - 0.01*4.0*b.y*(1.0-b.y);\n\t\tfloat isLip = 1.0-smoothstep( 0.0005, 0.0050, d1 );\n\t\tmateD = mix( mateD, vec3(0.14,0.04,0.05), 0.7*isLip );\n\t\tmateK = mix( mateK, vec2(0.4,1.5), isLip );\n\t\t}\n\t\t\n\t\tmateK *= 0.5 + no;\n\t}\n\telse if( m<2.5 )\n\t{\n\t\tmateD = vec3(0.18,0.18,0.225)*0.85;\n\t\tmateK = vec2(0.5,10.0);\n\t\tmateSG = vec3(1.0,1.0,0.9);\n\t\t\n\t\tvec3 p = transformHead( pos );\n\t\tvec3 q = vec3( abs(p.x), p.yz );\n\t\t\n\t\tvec2 r = q.xy-vec2(0.102+0.004*sign(p.x),0.03+0.004);\n\t\t\n\t\tfloat m = length(r) - 0.042;\n\t\tif( m<0.0 )\n\t\t{\n\t\t\tm = abs(m);\n\t\t\tmateD = mix( mateD, vec3(0.0), smoothstep(0.0,0.003,m));\n\t\t\tmateD = mix( mateD, vec3(0.06,0.02,0.0), smoothstep(0.003,0.006,m));\n\t\t\t\n\t\t\tr.x *= -sign(p.x);\n\t\t\tfloat an = atan(r.y,r.x) + 1.5;\n\t\t\tfloat ca = 1.0-smoothstep(0.0,1.0,abs(an-1.0));\n\t\t\tca *= 1.0-smoothstep(0.0,0.008,abs(m-0.011));\n\n\t\t\tfloat te = texture(iChannel0, vec2(an*0.1,m)).x;\n\t\t\tmateD = mix( mateD, (1.8*te*vec3(0.06,0.02,0.0)+(0.5+0.5*te)*ca*1.3*vec3(0.1,0.07,0.05)), smoothstep(0.003,0.006,m));\n\n\t\t\tmateD = mix( mateD, vec3(0.0), smoothstep(0.017,0.018,m-0.001));\n\t\t\tmateK = vec2(0.05,8.0);\n\t\t}\n\n\t\tr = q.xy-vec2(0.105+0.03*sign(p.x),0.058);\n\t\tmateD += (1.0-smoothstep(0.00,0.012,length(r)))*1.0;\n\t}\n\telse if( m<3.5 )\n\t{\n\t\tfloat focc = smoothstep(0.0,1.0,matInfo);\n\n\t\tmateD = vec3(0.025,0.015,0.01)*0.6*focc;\n\t\tmateK = vec2(0.1*focc,1.0);\n\t}\n\telse if( m<4.5 )\n\t{\n\t\tvec3 hatp = pos;\n\t\thatp = transformHat(hatp);\n\t\thatp.y += 0.1;\n\t\tfloat f = abs(hatp.x)-hatp.z;\n\t\tf = smoothstep(0.19,0.2,f );\n\t\t\n\t\tvec3 blue = vec3(0.01,0.04,0.08);\n\t\tvec3 te = \n\t\ttexture( iChannel0, 0.15*pos.yz ).xyz+\n\t\ttexture( iChannel0, 1.0*pos.yz ).xyz;\n\t\tblue *= 0.5+0.5*te.z;\n\t\tmateD = mix( vec3(0.18), blue, f );\n\t\tmateS = 0.05;\n\t\t\n\t\t\t\n\t\tvec2 si = (hatp.xy-vec2(0.0,-0.18)) * 3.5;\n\t\tfloat h = si.y - 0.1*sin( 8.0*si.x );\n\t\th = min( abs(h-1.15)-0.06, abs(h-1.0)-0.015 );\n\t\th += clamp( (abs(hatp.x)-0.25)\/0.1, 0.0, 1.0 );\n\t\tmateD = mix( mateD, vec3(0.004,0.008,0.014), 1.0-smoothstep( 0.01, 0.02, h ) );\n\t\t\n\t}\n\telse if( m<5.5 )\n\t{\n\t\tmateD = 0.5*vec3(0.01,0.04,0.08);\n\t\tmateD *= 0.7+0.6*texture( iChannel0, 2.0*pos.xz ).x;\n\t\tmateS = 0.05;\n\t}\n\telse if( m<8.5 )\n\t{\n\t\tmateD = vec3(0.30,0.30,0.40)*0.5;\n\t\tmateK = vec2(0.5,1.0);\n\t\tmateS = 0.2;\n\t\t\n\t}\n\t\n\tfloat fre = clamp(1.0+dot(nor,rd), 0.0, 1.0 );\n\tfloat occ = calcAO( pos, nor );\n\t\n\tvec3 col = vec3(0.0);\n\t\n    {\n\t\t\/\/ key\n\t\tfloat dif1 = dot(nor,sunDir);\n\t\tvec3 hal = normalize( sunDir-rd );\n\t\tfloat spe = pow(clamp(dot(hal,nor),0.0,1.0),0.001+8.0*mateK.y);\n\t\tfloat sha = calcSoftShadow( pos+nor*0.0005, sunDir, 24.0 ); \n\t\tfloat ssha = 1.0;\n\t\tif( abs(m-3.0)<0.2 ) { dif1=0.5*dif1+0.5; sha=0.95*sha+0.05;  }\n\t\tif( abs(m-2.0)<0.2 ) { sha=clamp(0.2+sha*dif1*2.0,0.0,1.0); dif1=0.4+0.6*dif1; ssha=0.0; }\n\t\t\n\t\tdif1 = clamp(dif1,0.0,1.0);\n\n        float sks = (abs(m-1.0)<0.2)?0.5:0.0;\n\t\tvec3 sha3 = vec3((1.0-sks)*sha+sks*sqrt(sha),sha*0.4+0.6*sha*sha,sha*sha);\n\t\t\n\t\tcol += mateD*3.1*vec3(2.5,1.1,0.5)*dif1*sha3;\n\t\tcol += mateK.x*vec3(1.5,1.4,1.3)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(hal,nor),0.0,1.0),5.0))*ssha;\n    }\n\t{\n\t\t\/\/ fill\n\t\tcol += mateD*vec3(0.45,0.75,1.0)*occ*occ*occ*(0.5+0.5*nor.y)*4.5;\n\t\tfloat dif1 = 0.5 + 0.5*nor.y;\n\t\tfloat sha = 1.0;\n\t\tfloat spe = smoothstep( -0.15, 0.15, reflect(rd,nor).y );\n\t\tcol += mateK.x*vec3(0.7,0.9,1.0)*dif1*sha*spe*(0.04+0.96*pow(clamp(dot(rd,nor),0.0,1.0),5.0))*occ*occ*3.0;\n\t}\n\t{\n\t\t\/\/ bounce\n\t\tvec3 bak = normalize( sunDir*vec3(-1.0,-3.5,-1.0));\n\t\tfloat dif = clamp(0.3+0.7*dot(nor,bak),0.0,1.0);\n\t\tcol += mateD*vec3(1.2,0.8,0.6)*occ*occ*dif*2.5;\n\t}\n\t{\n\t\tcol += mateS*mateD*fre    *vec3(2.0,0.95,0.80)*0.7*occ;\n\t\tcol += mateS*mateD*fre*fre*vec3(1.1,0.80,0.65)*1.2*occ;\n\t}\n\n\tcol = pow( col, mateSG );\n\n    return col;\n}\n\n\/\/--------------------------------------------\n\nvec3 intersect( in vec3 ro, in vec3 rd, float mindist, float maxdist )\n{\n\tvec3 res = vec3(-1.0);\n\t\n\tfloat t = mindist;\n\tfor( int i=ZERO; i<150; i++ )\n\t{\n\t\tvec3 p = ro + t*rd;\n\t\tvec3 h = map( p );\n\t\tres = vec3(t,h.yz);\n\t\tif( abs(h.x)<0.00025 || t>maxdist ) break;\n\t\tt += h.x;\n\t}\n\treturn res;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 render( in vec3 ro, in vec3 rd, in vec2 uv, in int sampleID )\n{\n\tvec4 res = texture(iChannel1,uv);\n\tvec3 col = res.xyz;\n\t\n\tconst float mindist = 0.8;\n\tconst float maxdist = 1.8;\n\t\n\tvec3 tm = intersect( ro, rd, mindist, maxdist );\n\tif( tm.y>-0.5 && tm.x < maxdist )\n\t{\n\t\tcol = shade( ro, rd, tm.x, tm.y, tm.z );\n\t}\n\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tmat3 ca; vec3 ro; float fl;\n\tcomputeCamera( iTime, ca, ro, fl );\n#if AA<2\n\tvec2  p = (2.0*fragCoord-iResolution.xy)\/iResolution.y;\n    vec3  rd = normalize( ca*vec3(p,-fl) );\n\tvec3 col = render( ro, rd, fragCoord.xy\/iResolution.xy, 0 );\n#else\n\tvec3 col = vec3(0.0);\n\tfor( int m=ZERO; m<AA; m++ )\n\tfor( int n=ZERO; n<AA; n++ )\n\t{\n\t\tvec2 rr = vec2( float(m), float(n) ) \/ float(AA) - 0.5;\n\t\tvec2 p = (2.0*(fragCoord.xy+rr)-iResolution.xy)\/iResolution.y;\n\t\tvec3 rd = normalize( ca * vec3(p,-fl) );\n\t\tcol += render( ro, rd, (fragCoord+rr)\/iResolution.xy, AA*m+n );\n\t}    \n\tcol \/= float(AA*AA);\n#endif\n\t\t\n\tfragColor = vec4( col, 1.0 );\n}","name":"Buffer C","description":"","type":"buffer"}]}}